   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	XorWithIv:
  13               	.LFB14:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** 
 104:stk500boot.c  **** #include	<inttypes.h>
 105:stk500boot.c  **** #include	<avr/io.h>
 106:stk500boot.c  **** #include	<avr/interrupt.h>
 107:stk500boot.c  **** #include	<avr/boot.h>
 108:stk500boot.c  **** #include	<avr/pgmspace.h>
 109:stk500boot.c  **** #include	<util/delay.h>
 110:stk500boot.c  **** #include	<avr/eeprom.h>
 111:stk500boot.c  **** #include	<avr/common.h>
 112:stk500boot.c  **** #include	<stdlib.h>
 113:stk500boot.c  **** #include	"command.h"
 114:stk500boot.c  **** #include	<string.h>
 115:stk500boot.c  **** // #include 	"aes.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** const unsigned char iv [] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0
 118:stk500boot.c  **** const unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #undef ENABLE_MONITOR
 121:stk500boot.c  **** 
 122:stk500boot.c  **** 
 123:stk500boot.c  **** 
 124:stk500boot.c  **** // #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined
 125:stk500boot.c  **** // 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 126:stk500boot.c  **** // 	#undef		ENABLE_MONITOR
 127:stk500boot.c  **** // 	#define		ENABLE_MONITOR
 128:stk500boot.c  **** // 	static void	RunMonitor(void);
 129:stk500boot.c  **** // #endif
 130:stk500boot.c  **** 
 131:stk500boot.c  **** #ifndef EEWE
 132:stk500boot.c  **** 	#define EEWE    1
 133:stk500boot.c  **** #endif
 134:stk500boot.c  **** #ifndef EEMWE
 135:stk500boot.c  **** 	#define EEMWE   2
 136:stk500boot.c  **** #endif
 137:stk500boot.c  **** 
 138:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 139:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** /*
 143:stk500boot.c  ****  * Uncomment the following lines to save code space
 144:stk500boot.c  ****  */
 145:stk500boot.c  **** #define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 146:stk500boot.c  **** #define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 147:stk500boot.c  **** #define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for A
 148:stk500boot.c  **** //
 149:stk500boot.c  **** 
 150:stk500boot.c  **** 
 151:stk500boot.c  **** 
 152:stk500boot.c  **** //************************************************************************
 153:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 154:stk500boot.c  **** //*	indicates that bootloader is active
 155:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 156:stk500boot.c  **** //************************************************************************
 157:stk500boot.c  **** //#define		BLINK_LED_WHILE_WAITING
 158:stk500boot.c  **** 
 159:stk500boot.c  **** #ifdef _MEGA_BOARD_
 160:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 161:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 162:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 163:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 164:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 165:stk500boot.c  **** 	//*	onbarod led is PORTE4
 166:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 167:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 168:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 169:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 170:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 171:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 172:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 173:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 174:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 175:stk500boot.c  **** #elif defined( _PENGUINO_ )
 176:stk500boot.c  **** 	//*	this is for the Penguino
 177:stk500boot.c  **** 	//*	onbarod led is PORTE4
 178:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 179:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 180:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 181:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 182:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 183:stk500boot.c  **** 	//*	onbarod led is PORTE4
 184:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 185:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 186:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 187:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 188:stk500boot.c  **** 	//*	onbarod led is PORTA7
 189:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 190:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 191:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 192:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 193:stk500boot.c  **** 
 194:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 195:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 196:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 197:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 198:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 199:stk500boot.c  **** 
 200:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 201:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 202:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 203:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 204:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 205:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 206:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 207:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 208:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 209:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 210:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 211:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 212:stk500boot.c  **** #elif defined( _AVRLIP_ )
 213:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 214:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 215:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 216:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 217:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 218:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 219:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 220:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 221:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 222:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 223:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 224:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 225:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 226:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 227:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 228:stk500boot.c  **** #else
 229:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 230:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 231:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 232:stk500boot.c  **** #endif
 233:stk500boot.c  **** 
 234:stk500boot.c  **** 
 235:stk500boot.c  **** 
 236:stk500boot.c  **** /*
 237:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 238:stk500boot.c  ****  */
 239:stk500boot.c  **** #ifndef F_CPU
 240:stk500boot.c  **** 	#define F_CPU 16000000UL
 241:stk500boot.c  **** #endif
 242:stk500boot.c  **** 
 243:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 244:stk500boot.c  **** /*
 245:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 246:stk500boot.c  ****  */
 247:stk500boot.c  **** 
 248:stk500boot.c  **** #ifndef BAUDRATE
 249:stk500boot.c  **** 	#define BAUDRATE 115200
 250:stk500boot.c  **** #endif
 251:stk500boot.c  **** 
 252:stk500boot.c  **** /*
 253:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 254:stk500boot.c  ****  */
 255:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 256:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 257:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 258:stk500boot.c  **** 	#else
 259:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 260:stk500boot.c  **** 	#endif
 261:stk500boot.c  **** #endif
 262:stk500boot.c  **** 
 263:stk500boot.c  **** /*
 264:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 265:stk500boot.c  ****  */
 266:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 267:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 268:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 269:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 270:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 271:stk500boot.c  **** 
 272:stk500boot.c  **** /*
 273:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 274:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 275:stk500boot.c  ****  */
 276:stk500boot.c  **** //#define BOOTSIZE 1024
 277:stk500boot.c  **** #if FLASHEND > 0x0F000
 278:stk500boot.c  **** 	#define BOOTSIZE 8192
 279:stk500boot.c  **** #else
 280:stk500boot.c  **** 	#define BOOTSIZE 2048
 281:stk500boot.c  **** #endif
 282:stk500boot.c  **** 
 283:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 284:stk500boot.c  **** 
 285:stk500boot.c  **** /*
 286:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 287:stk500boot.c  ****  */
 288:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 289:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 290:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 291:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 292:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 293:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 294:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 295:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 296:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 297:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 298:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 299:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 300:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 301:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 302:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 303:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 304:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 305:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 306:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 307:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 308:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 309:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 310:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 311:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 312:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 313:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 314:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 315:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 316:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 317:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 318:stk500boot.c  **** #else
 319:stk500boot.c  **** 	#error "no signature definition for MCU available"
 320:stk500boot.c  **** #endif
 321:stk500boot.c  **** 
 322:stk500boot.c  **** 
 323:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 324:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 325:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 326:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 327:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 328:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 329:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 330:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 331:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 332:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 333:stk500boot.c  **** 
 334:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 335:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 336:stk500boot.c  **** 	/* ATMega8 with one USART */
 337:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 338:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 339:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 340:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 341:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 342:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 343:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 344:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 345:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 346:stk500boot.c  **** 
 347:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 348:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 349:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 350:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 351:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 352:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 353:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 354:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 355:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 356:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 357:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 358:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 359:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 360:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 361:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 362:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 363:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 364:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 365:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 366:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 367:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 368:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 369:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 370:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 371:stk500boot.c  **** 	//* catch all
 372:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 373:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 374:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 375:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 376:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 377:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 378:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 379:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 380:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 381:stk500boot.c  **** #else
 382:stk500boot.c  **** 	#error "no UART definition for MCU available"
 383:stk500boot.c  **** #endif
 384:stk500boot.c  **** 
 385:stk500boot.c  **** 
 386:stk500boot.c  **** 
 387:stk500boot.c  **** /*
 388:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 389:stk500boot.c  ****  */
 390:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 391:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 392:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 393:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 394:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 395:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 396:stk500boot.c  **** #else
 397:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 398:stk500boot.c  **** #endif
 399:stk500boot.c  **** 
 400:stk500boot.c  **** 
 401:stk500boot.c  **** 
 402:stk500boot.c  **** 
 403:stk500boot.c  **** /*
 404:stk500boot.c  ****  * States used in the receive state machine
 405:stk500boot.c  ****  */
 406:stk500boot.c  **** #define	ST_START		0
 407:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 408:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 409:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 410:stk500boot.c  **** #define ST_GET_TOKEN	4
 411:stk500boot.c  **** #define ST_GET_DATA		5
 412:stk500boot.c  **** #define	ST_GET_CHECK	6
 413:stk500boot.c  **** #define	ST_PROCESS		7
 414:stk500boot.c  **** 
 415:stk500boot.c  **** /*
 416:stk500boot.c  ****  * States used in the encrypted command packet stage.
 417:stk500boot.c  ****  */
 418:stk500boot.c  **** #define 	SOTA_MESSAGE_START 0x58
 419:stk500boot.c  ****  #define	SOTA_PACKET_RETRIEVE_START		0
 420:stk500boot.c  ****  #define  SOTA_PACKET_RETRIEVE_SIZE    1
 421:stk500boot.c  ****  #define	SOTA_PACKET_RETRIEVE_PROCESSING		2
 422:stk500boot.c  ****  #define	SOTA_PACKET_RETRIEVE_FINISHED		3
 423:stk500boot.c  **** 
 424:stk500boot.c  **** /*
 425:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 426:stk500boot.c  ****  */
 427:stk500boot.c  **** #if defined(RAMPZ)
 428:stk500boot.c  **** 	typedef uint32_t address_t;
 429:stk500boot.c  **** #else
 430:stk500boot.c  **** 	typedef uint16_t address_t;
 431:stk500boot.c  **** #endif
 432:stk500boot.c  **** 
 433:stk500boot.c  **** /*
 434:stk500boot.c  ****  * function prototypes
 435:stk500boot.c  ****  */
 436:stk500boot.c  **** static void sendchar(char c);
 437:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
 438:stk500boot.c  **** {
 439:stk500boot.c  **** int	theChar;
 440:stk500boot.c  **** int	myNumber;
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	myNumber	=	theNumber;
 443:stk500boot.c  **** 
 444:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 445:stk500boot.c  **** 	{
 446:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
 447:stk500boot.c  **** 		sendchar(theChar );
 448:stk500boot.c  **** 	}
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 451:stk500boot.c  **** 	{
 452:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
 453:stk500boot.c  **** 		sendchar(theChar );
 454:stk500boot.c  **** 	}
 455:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
 456:stk500boot.c  **** 	sendchar(theChar );
 457:stk500boot.c  **** }
 458:stk500boot.c  **** static unsigned char recchar(void);
 459:stk500boot.c  **** //Burak
 460:stk500boot.c  **** #define Nb 4
 461:stk500boot.c  **** // The number of 32 bit words in a key.
 462:stk500boot.c  **** #define Nk 4
 463:stk500boot.c  **** 
 464:stk500boot.c  **** // The number of rounds in AES Cipher.
 465:stk500boot.c  **** #define Nr 10
 466:stk500boot.c  **** 
 467:stk500boot.c  **** #define BLOCKLEN 16
 468:stk500boot.c  **** 
 469:stk500boot.c  **** // jcallan@github points out that declaring Multiply as a function
 470:stk500boot.c  **** // reduces code size considerably with the Keil ARM compiler.
 471:stk500boot.c  **** // See this link for more information: https://github.com/kokke/tiny-AES128-C/pull/3
 472:stk500boot.c  **** #ifndef MULTIPLY_AS_A_FUNCTION
 473:stk500boot.c  ****   #define MULTIPLY_AS_A_FUNCTION 0
 474:stk500boot.c  **** #endif
 475:stk500boot.c  **** 
 476:stk500boot.c  **** 
 477:stk500boot.c  **** /*****************************************************************************/
 478:stk500boot.c  **** /* Private variables:                                                        */
 479:stk500boot.c  **** /*****************************************************************************/
 480:stk500boot.c  **** // state - array holding the intermediate results during decryption.
 481:stk500boot.c  **** typedef unsigned char state_t[4][4];
 482:stk500boot.c  **** static state_t* state;
 483:stk500boot.c  **** 
 484:stk500boot.c  **** // The array that stores the round keys.
 485:stk500boot.c  **** static unsigned char RoundKey[176];
 486:stk500boot.c  **** 
 487:stk500boot.c  **** // The Key input to the AES Program
 488:stk500boot.c  **** static const unsigned char* Key;
 489:stk500boot.c  **** 
 490:stk500boot.c  **** // #if defined(CBC) && CBC
 491:stk500boot.c  ****   // Initial Vector used only for CBC mode
 492:stk500boot.c  ****   static unsigned char* Iv;
 493:stk500boot.c  **** // #endif
 494:stk500boot.c  **** 
 495:stk500boot.c  **** // The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
 496:stk500boot.c  **** // The numbers below can be computed dynamically trading ROM for RAM -
 497:stk500boot.c  **** // This can be useful in (embedded) bootloader applications, where ROM is often limited.
 498:stk500boot.c  **** static const unsigned char sbox[256] =   {
 499:stk500boot.c  ****   //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
 500:stk500boot.c  ****   0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
 501:stk500boot.c  ****   0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
 502:stk500boot.c  ****   0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
 503:stk500boot.c  ****   0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
 504:stk500boot.c  ****   0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
 505:stk500boot.c  ****   0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
 506:stk500boot.c  ****   0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
 507:stk500boot.c  ****   0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
 508:stk500boot.c  ****   0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
 509:stk500boot.c  ****   0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
 510:stk500boot.c  ****   0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
 511:stk500boot.c  ****   0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
 512:stk500boot.c  ****   0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
 513:stk500boot.c  ****   0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
 514:stk500boot.c  ****   0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
 515:stk500boot.c  ****   0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
 516:stk500boot.c  **** 
 517:stk500boot.c  **** static const unsigned char rsbox[256] =
 518:stk500boot.c  **** { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
 519:stk500boot.c  ****   0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
 520:stk500boot.c  ****   0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
 521:stk500boot.c  ****   0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
 522:stk500boot.c  ****   0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
 523:stk500boot.c  ****   0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
 524:stk500boot.c  ****   0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
 525:stk500boot.c  ****   0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
 526:stk500boot.c  ****   0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
 527:stk500boot.c  ****   0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
 528:stk500boot.c  ****   0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
 529:stk500boot.c  ****   0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
 530:stk500boot.c  ****   0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
 531:stk500boot.c  ****   0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
 532:stk500boot.c  ****   0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
 533:stk500boot.c  ****   0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
 534:stk500boot.c  **** 
 535:stk500boot.c  **** 
 536:stk500boot.c  **** // The round constant word array, Rcon[i], contains the values given by
 537:stk500boot.c  **** // x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
 538:stk500boot.c  **** // Note that i starts at 1, not 0).
 539:stk500boot.c  **** static const unsigned char Rcon[255] = {
 540:stk500boot.c  ****   0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
 541:stk500boot.c  ****   0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
 542:stk500boot.c  ****   0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
 543:stk500boot.c  ****   0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
 544:stk500boot.c  ****   0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
 545:stk500boot.c  ****   0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
 546:stk500boot.c  ****   0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
 547:stk500boot.c  ****   0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
 548:stk500boot.c  ****   0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
 549:stk500boot.c  ****   0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
 550:stk500boot.c  ****   0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
 551:stk500boot.c  ****   0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
 552:stk500boot.c  ****   0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
 553:stk500boot.c  ****   0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
 554:stk500boot.c  ****   0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
 555:stk500boot.c  ****   0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };
 556:stk500boot.c  **** 
 557:stk500boot.c  **** 
 558:stk500boot.c  **** /*****************************************************************************/
 559:stk500boot.c  **** /* Private functions:                                                        */
 560:stk500boot.c  **** /*****************************************************************************/
 561:stk500boot.c  **** static unsigned char getSBoxValue(unsigned char num)
 562:stk500boot.c  **** {
 563:stk500boot.c  ****   return sbox[num];
 564:stk500boot.c  **** }
 565:stk500boot.c  **** 
 566:stk500boot.c  **** static unsigned char getSBoxInvert(unsigned char num)
 567:stk500boot.c  **** {
 568:stk500boot.c  ****   return rsbox[num];
 569:stk500boot.c  **** }
 570:stk500boot.c  **** static void XorWithIv(unsigned char* buf)
 571:stk500boot.c  **** {
  15               		.loc 1 571 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 E091 0000 		lds r30,Iv
  23 0004 F091 0000 		lds r31,Iv+1
  24 0008 AC01      		movw r20,r24
  25 000a 405F      		subi r20,-16
  26 000c 5F4F      		sbci r21,-1
  27               	.LVL1:
  28               	.L2:
 572:stk500boot.c  ****   unsigned char i;
 573:stk500boot.c  ****   for(i = 0; i < 16; ++i)
 574:stk500boot.c  ****   {
 575:stk500boot.c  ****     buf[i] ^= Iv[i];
  29               		.loc 1 575 0 discriminator 3
  30 000e DC01      		movw r26,r24
  31 0010 2D91      		ld r18,X+
  32 0012 CD01      		movw r24,r26
  33               	.LVL2:
  34 0014 3191      		ld r19,Z+
  35 0016 1197      		sbiw r26,1
  36 0018 2327      		eor r18,r19
  37 001a 2C93      		st X,r18
  38               	.LVL3:
 573:stk500boot.c  ****   {
  39               		.loc 1 573 0 discriminator 3
  40 001c 8417      		cp r24,r20
  41 001e 9507      		cpc r25,r21
  42 0020 01F4      		brne .L2
  43               	/* epilogue start */
 576:stk500boot.c  ****   }
 577:stk500boot.c  **** }
  44               		.loc 1 577 0
  45 0022 0895      		ret
  46               		.cfi_endproc
  47               	.LFE14:
  50               	KeyExpansion:
  51               	.LFB15:
 578:stk500boot.c  **** // This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the
 579:stk500boot.c  **** static void KeyExpansion(void)
 580:stk500boot.c  **** {
  52               		.loc 1 580 0
  53               		.cfi_startproc
  54 0024 8F92      		push r8
  55               	.LCFI0:
  56               		.cfi_def_cfa_offset 4
  57               		.cfi_offset 8, -3
  58 0026 9F92      		push r9
  59               	.LCFI1:
  60               		.cfi_def_cfa_offset 5
  61               		.cfi_offset 9, -4
  62 0028 AF92      		push r10
  63               	.LCFI2:
  64               		.cfi_def_cfa_offset 6
  65               		.cfi_offset 10, -5
  66 002a BF92      		push r11
  67               	.LCFI3:
  68               		.cfi_def_cfa_offset 7
  69               		.cfi_offset 11, -6
  70 002c FF92      		push r15
  71               	.LCFI4:
  72               		.cfi_def_cfa_offset 8
  73               		.cfi_offset 15, -7
  74 002e 0F93      		push r16
  75               	.LCFI5:
  76               		.cfi_def_cfa_offset 9
  77               		.cfi_offset 16, -8
  78 0030 1F93      		push r17
  79               	.LCFI6:
  80               		.cfi_def_cfa_offset 10
  81               		.cfi_offset 17, -9
  82 0032 CF93      		push r28
  83               	.LCFI7:
  84               		.cfi_def_cfa_offset 11
  85               		.cfi_offset 28, -10
  86 0034 DF93      		push r29
  87               	.LCFI8:
  88               		.cfi_def_cfa_offset 12
  89               		.cfi_offset 29, -11
  90 0036 00D0      		rcall .
  91 0038 1F92      		push __zero_reg__
  92               	.LCFI9:
  93               		.cfi_def_cfa_offset 16
  94 003a CDB7      		in r28,__SP_L__
  95 003c DEB7      		in r29,__SP_H__
  96               	.LCFI10:
  97               		.cfi_def_cfa_register 28
  98               	/* prologue: function */
  99               	/* frame size = 4 */
 100               	/* stack size = 13 */
 101               	.L__stack_usage = 13
 102               	.LVL4:
 103 003e 6091 0000 		lds r22,Key
 104 0042 7091 0000 		lds r23,Key+1
 105 0046 E0E0      		ldi r30,lo8(RoundKey)
 106 0048 F0E0      		ldi r31,hi8(RoundKey)
 107 004a 9B01      		movw r18,r22
 108 004c 205F      		subi r18,-16
 109 004e 3F4F      		sbci r19,-1
 581:stk500boot.c  ****   uint32_t i, j, k;
 582:stk500boot.c  ****   unsigned char tempa[4]; // Used for the column/row operations
 583:stk500boot.c  **** 
 584:stk500boot.c  ****   // The first round key is the key itself.
 585:stk500boot.c  ****   for(i = 0; i < Nk; ++i)
 586:stk500boot.c  ****   {
 587:stk500boot.c  ****     RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
 110               		.loc 1 587 0
 111 0050 CF01      		movw r24,r30
 112               	.LVL5:
 113               	.L5:
 114               		.loc 1 587 0 is_stmt 0 discriminator 3
 115 0052 DB01      		movw r26,r22
 116 0054 4C91      		ld r20,X
 117 0056 DC01      		movw r26,r24
 118 0058 4C93      		st X,r20
 588:stk500boot.c  ****     RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
 119               		.loc 1 588 0 is_stmt 1 discriminator 3
 120 005a DB01      		movw r26,r22
 121 005c 1196      		adiw r26,1
 122 005e 4C91      		ld r20,X
 123 0060 DC01      		movw r26,r24
 124 0062 1196      		adiw r26,1
 125 0064 4C93      		st X,r20
 589:stk500boot.c  ****     RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
 126               		.loc 1 589 0 discriminator 3
 127 0066 DB01      		movw r26,r22
 128 0068 1296      		adiw r26,2
 129 006a 4C91      		ld r20,X
 130 006c DC01      		movw r26,r24
 131 006e 1296      		adiw r26,2
 132 0070 4C93      		st X,r20
 590:stk500boot.c  ****     RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
 133               		.loc 1 590 0 discriminator 3
 134 0072 DB01      		movw r26,r22
 135 0074 1396      		adiw r26,3
 136 0076 4C91      		ld r20,X
 137 0078 DC01      		movw r26,r24
 138 007a 1396      		adiw r26,3
 139 007c 4C93      		st X,r20
 140 007e 6C5F      		subi r22,-4
 141 0080 7F4F      		sbci r23,-1
 142 0082 0496      		adiw r24,4
 585:stk500boot.c  ****   {
 143               		.loc 1 585 0 discriminator 3
 144 0084 6217      		cp r22,r18
 145 0086 7307      		cpc r23,r19
 146 0088 01F4      		brne .L5
 147 008a 94E0      		ldi r25,lo8(4)
 148 008c 892E      		mov r8,r25
 149 008e 912C      		mov r9,__zero_reg__
 150 0090 A12C      		mov r10,__zero_reg__
 151 0092 B12C      		mov r11,__zero_reg__
 152 0094 BE01      		movw r22,r28
 153 0096 6B5F      		subi r22,-5
 154 0098 7F4F      		sbci r23,-1
 155               	.L6:
 156               	.LVL6:
 157 009a AF01      		movw r20,r30
 158 009c 445F      		subi r20,-12
 159 009e 5F4F      		sbci r21,-1
 160 00a0 9E01      		movw r18,r28
 161 00a2 2F5F      		subi r18,-1
 162 00a4 3F4F      		sbci r19,-1
 163               	.LVL7:
 164               	.L7:
 591:stk500boot.c  ****   }
 592:stk500boot.c  **** 
 593:stk500boot.c  ****   // All other round keys are found from the previous round keys.
 594:stk500boot.c  ****   for(; (i < (Nb * (Nr + 1))); ++i)
 595:stk500boot.c  ****   {
 596:stk500boot.c  ****     for(j = 0; j < 4; ++j)
 597:stk500boot.c  ****     {
 598:stk500boot.c  ****       tempa[j]=RoundKey[(i-1) * 4 + j];
 165               		.loc 1 598 0 discriminator 3
 166 00a6 DA01      		movw r26,r20
 167 00a8 1D91      		ld r17,X+
 168 00aa AD01      		movw r20,r26
 169 00ac D901      		movw r26,r18
 170 00ae 1D93      		st X+,r17
 171 00b0 9D01      		movw r18,r26
 596:stk500boot.c  ****     {
 172               		.loc 1 596 0 discriminator 3
 173 00b2 6A17      		cp r22,r26
 174 00b4 7B07      		cpc r23,r27
 175 00b6 01F4      		brne .L7
 599:stk500boot.c  ****     }
 600:stk500boot.c  ****     if (i % Nk == 0)
 176               		.loc 1 600 0
 177 00b8 9501      		movw r18,r10
 178 00ba 8401      		movw r16,r8
 179 00bc 0370      		andi r16,3
 180 00be 1127      		clr r17
 181 00c0 2227      		clr r18
 182 00c2 3327      		clr r19
 183 00c4 012B      		or r16,r17
 184 00c6 022B      		or r16,r18
 185 00c8 032B      		or r16,r19
 186 00ca 01F4      		brne .L8
 187 00cc 2981      		ldd r18,Y+1
 188 00ce 4C81      		ldd r20,Y+4
 189               	.LVL8:
 190               	.LBB54:
 191               	.LBB55:
 563:stk500boot.c  **** }
 192               		.loc 1 563 0
 193 00d0 0A81      		ldd r16,Y+2
 194 00d2 10E0      		ldi r17,0
 195 00d4 0050      		subi r16,lo8(-(sbox))
 196 00d6 1040      		sbci r17,hi8(-(sbox))
 197 00d8 D801      		movw r26,r16
 198 00da FC90      		ld r15,X
 199               	.LVL9:
 200               	.LBE55:
 201               	.LBE54:
 202               	.LBB56:
 203               	.LBB57:
 204 00dc 0B81      		ldd r16,Y+3
 205 00de 10E0      		ldi r17,0
 206 00e0 0050      		subi r16,lo8(-(sbox))
 207 00e2 1040      		sbci r17,hi8(-(sbox))
 208               	.LBE57:
 209               	.LBE56:
 601:stk500boot.c  ****     {
 602:stk500boot.c  ****       // This function rotates the 4 bytes in a word to the left once.
 603:stk500boot.c  ****       // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
 604:stk500boot.c  **** 
 605:stk500boot.c  ****       // Function RotWord()
 606:stk500boot.c  ****       {
 607:stk500boot.c  ****         k = tempa[0];
 608:stk500boot.c  ****         tempa[0] = tempa[1];
 609:stk500boot.c  ****         tempa[1] = tempa[2];
 610:stk500boot.c  ****         tempa[2] = tempa[3];
 611:stk500boot.c  ****         tempa[3] = k;
 612:stk500boot.c  ****       }
 613:stk500boot.c  **** 
 614:stk500boot.c  ****       // SubWord() is a function that takes a four-byte input word and
 615:stk500boot.c  ****       // applies the S-box to each of the four bytes to produce an output word.
 616:stk500boot.c  **** 
 617:stk500boot.c  ****       // Function Subword()
 618:stk500boot.c  ****       {
 619:stk500boot.c  ****         tempa[0] = getSBoxValue(tempa[0]);
 620:stk500boot.c  ****         tempa[1] = getSBoxValue(tempa[1]);
 210               		.loc 1 620 0
 211 00e4 D801      		movw r26,r16
 212 00e6 3C91      		ld r19,X
 213 00e8 3A83      		std Y+2,r19
 214               	.LBB58:
 215               	.LBB59:
 563:stk500boot.c  **** }
 216               		.loc 1 563 0
 217 00ea 50E0      		ldi r21,0
 218 00ec 4050      		subi r20,lo8(-(sbox))
 219 00ee 5040      		sbci r21,hi8(-(sbox))
 220               	.LBE59:
 221               	.LBE58:
 621:stk500boot.c  ****         tempa[2] = getSBoxValue(tempa[2]);
 222               		.loc 1 621 0
 223 00f0 DA01      		movw r26,r20
 224 00f2 3C91      		ld r19,X
 225 00f4 3B83      		std Y+3,r19
 226               	.LBB60:
 227               	.LBB61:
 563:stk500boot.c  **** }
 228               		.loc 1 563 0
 229 00f6 30E0      		ldi r19,0
 230 00f8 2050      		subi r18,lo8(-(sbox))
 231 00fa 3040      		sbci r19,hi8(-(sbox))
 232               	.LVL10:
 233               	.LBE61:
 234               	.LBE60:
 622:stk500boot.c  ****         tempa[3] = getSBoxValue(tempa[3]);
 235               		.loc 1 622 0
 236 00fc D901      		movw r26,r18
 237 00fe 2C91      		ld r18,X
 238 0100 2C83      		std Y+4,r18
 623:stk500boot.c  ****       }
 624:stk500boot.c  **** 
 625:stk500boot.c  ****       tempa[0] =  tempa[0] ^ Rcon[i/Nk];
 239               		.loc 1 625 0
 240 0102 9501      		movw r18,r10
 241 0104 8401      		movw r16,r8
 242 0106 82E0      		ldi r24,2
 243               		1:
 244 0108 3695      		lsr r19
 245 010a 2795      		ror r18
 246 010c 1795      		ror r17
 247 010e 0795      		ror r16
 248 0110 8A95      		dec r24
 249 0112 01F4      		brne 1b
 250 0114 0050      		subi r16,lo8(-(Rcon))
 251 0116 1040      		sbci r17,hi8(-(Rcon))
 252 0118 D801      		movw r26,r16
 253 011a 2C91      		ld r18,X
 254 011c 2F25      		eor r18,r15
 255 011e 2983      		std Y+1,r18
 256               	.LVL11:
 257               	.L8:
 626:stk500boot.c  ****     }
 627:stk500boot.c  ****     else if (Nk > 6 && i % Nk == 4)
 628:stk500boot.c  ****     {
 629:stk500boot.c  ****       // Function Subword()
 630:stk500boot.c  ****       {
 631:stk500boot.c  ****         tempa[0] = getSBoxValue(tempa[0]);
 632:stk500boot.c  ****         tempa[1] = getSBoxValue(tempa[1]);
 633:stk500boot.c  ****         tempa[2] = getSBoxValue(tempa[2]);
 634:stk500boot.c  ****         tempa[3] = getSBoxValue(tempa[3]);
 635:stk500boot.c  ****       }
 636:stk500boot.c  ****     }
 637:stk500boot.c  ****     // uint32_t brk = 0xFF ^ tempa[0];
 638:stk500boot.c  ****     // static unsigned char burakim[1024];
 639:stk500boot.c  ****     // for(uint8_t i =0; i<1024;i++)
 640:stk500boot.c  ****     // burakim[i] = 0xFF;
 641:stk500boot.c  ****     // RoundKey[i * 4 + 0] = RoundKey[(i - Nk) * 4 + 0];
 642:stk500boot.c  **** 		// sendchar(0x91);
 643:stk500boot.c  ****     RoundKey[i * 4 + 0] = RoundKey[(i - Nk) * 4 + 0] ^ tempa[0];
 258               		.loc 1 643 0
 259 0120 2081      		ld r18,Z
 260 0122 3981      		ldd r19,Y+1
 261 0124 2327      		eor r18,r19
 262 0126 208B      		std Z+16,r18
 644:stk500boot.c  **** 		// sendchar(0x92);
 645:stk500boot.c  ****     RoundKey[i * 4 + 1] = RoundKey[(i - Nk) * 4 + 1] ^ tempa[1];
 263               		.loc 1 645 0
 264 0128 2181      		ldd r18,Z+1
 265 012a 3A81      		ldd r19,Y+2
 266 012c 2327      		eor r18,r19
 267 012e 218B      		std Z+17,r18
 646:stk500boot.c  **** 		// sendchar(0x93);
 647:stk500boot.c  ****     RoundKey[i * 4 + 2] = RoundKey[(i - Nk) * 4 + 2] ^ tempa[2];
 268               		.loc 1 647 0
 269 0130 2281      		ldd r18,Z+2
 270 0132 3B81      		ldd r19,Y+3
 271 0134 2327      		eor r18,r19
 272 0136 228B      		std Z+18,r18
 648:stk500boot.c  **** 		// sendchar(0x94);
 649:stk500boot.c  ****     RoundKey[i * 4 + 3] = RoundKey[(i - Nk) * 4 + 3] ^ tempa[3];
 273               		.loc 1 649 0
 274 0138 2381      		ldd r18,Z+3
 275 013a 3C81      		ldd r19,Y+4
 276 013c 2327      		eor r18,r19
 277 013e 238B      		std Z+19,r18
 594:stk500boot.c  ****   {
 278               		.loc 1 594 0
 279 0140 BFEF      		ldi r27,-1
 280 0142 8B1A      		sub r8,r27
 281 0144 9B0A      		sbc r9,r27
 282 0146 AB0A      		sbc r10,r27
 283 0148 BB0A      		sbc r11,r27
 284               	.LVL12:
 285 014a 3496      		adiw r30,4
 286 014c 8CE2      		ldi r24,44
 287 014e 8816      		cp r8,r24
 288 0150 9104      		cpc r9,__zero_reg__
 289 0152 A104      		cpc r10,__zero_reg__
 290 0154 B104      		cpc r11,__zero_reg__
 291 0156 01F0      		breq .+2
 292 0158 00C0      		rjmp .L6
 293               	/* epilogue start */
 650:stk500boot.c  **** 		// sendchar(0x95);
 651:stk500boot.c  ****   }
 652:stk500boot.c  **** }
 294               		.loc 1 652 0
 295 015a 0F90      		pop __tmp_reg__
 296 015c 0F90      		pop __tmp_reg__
 297 015e 0F90      		pop __tmp_reg__
 298 0160 0F90      		pop __tmp_reg__
 299 0162 DF91      		pop r29
 300 0164 CF91      		pop r28
 301 0166 1F91      		pop r17
 302 0168 0F91      		pop r16
 303 016a FF90      		pop r15
 304 016c BF90      		pop r11
 305 016e AF90      		pop r10
 306 0170 9F90      		pop r9
 307 0172 8F90      		pop r8
 308               	.LVL13:
 309 0174 0895      		ret
 310               		.cfi_endproc
 311               	.LFE15:
 314               	AddRoundKey:
 315               	.LFB16:
 653:stk500boot.c  **** 
 654:stk500boot.c  **** // This function adds the round key to state.
 655:stk500boot.c  **** // The round key is added to the state by an XOR function.
 656:stk500boot.c  **** static void AddRoundKey(unsigned char round)
 657:stk500boot.c  **** {
 316               		.loc 1 657 0
 317               		.cfi_startproc
 318               	.LVL14:
 319 0176 1F93      		push r17
 320               	.LCFI11:
 321               		.cfi_def_cfa_offset 4
 322               		.cfi_offset 17, -3
 323 0178 CF93      		push r28
 324               	.LCFI12:
 325               		.cfi_def_cfa_offset 5
 326               		.cfi_offset 28, -4
 327 017a DF93      		push r29
 328               	.LCFI13:
 329               		.cfi_def_cfa_offset 6
 330               		.cfi_offset 29, -5
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 3 */
 334               	.L__stack_usage = 3
 335               	.LVL15:
 658:stk500boot.c  ****   unsigned char i,j;
 659:stk500boot.c  ****   for(i=0;i<4;++i)
 660:stk500boot.c  ****   {
 661:stk500boot.c  ****     for(j = 0; j < 4; ++j)
 662:stk500boot.c  ****     {
 663:stk500boot.c  ****       (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];
 336               		.loc 1 663 0
 337 017c 6091 0000 		lds r22,state
 338 0180 7091 0000 		lds r23,state+1
 339 0184 90E1      		ldi r25,lo8(16)
 340 0186 899F      		mul r24,r25
 341 0188 A001      		movw r20,r0
 342 018a 1124      		clr __zero_reg__
 343 018c 30E0      		ldi r19,0
 344 018e 20E0      		ldi r18,0
 345 0190 4050      		subi r20,lo8(-(RoundKey))
 346 0192 5040      		sbci r21,hi8(-(RoundKey))
 347               	.LVL16:
 348               	.L13:
 349 0194 FB01      		movw r30,r22
 350 0196 E20F      		add r30,r18
 351 0198 F31F      		adc r31,r19
 352 019a DA01      		movw r26,r20
 353 019c A20F      		add r26,r18
 354 019e B31F      		adc r27,r19
 661:stk500boot.c  ****     {
 355               		.loc 1 661 0
 356 01a0 90E0      		ldi r25,0
 357               	.LVL17:
 358               	.L14:
 359               		.loc 1 663 0 discriminator 3
 360 01a2 8191      		ld r24,Z+
 361 01a4 1D91      		ld r17,X+
 362 01a6 EF01      		movw r28,r30
 363 01a8 2197      		sbiw r28,1
 364 01aa 8127      		eor r24,r17
 365 01ac 8883      		st Y,r24
 661:stk500boot.c  ****     {
 366               		.loc 1 661 0 discriminator 3
 367 01ae 9F5F      		subi r25,lo8(-(1))
 368               	.LVL18:
 369 01b0 9430      		cpi r25,lo8(4)
 370 01b2 01F4      		brne .L14
 371 01b4 2C5F      		subi r18,-4
 372 01b6 3F4F      		sbci r19,-1
 659:stk500boot.c  ****   {
 373               		.loc 1 659 0 discriminator 2
 374 01b8 2031      		cpi r18,16
 375 01ba 3105      		cpc r19,__zero_reg__
 376 01bc 01F4      		brne .L13
 377               	/* epilogue start */
 664:stk500boot.c  ****     }
 665:stk500boot.c  ****   }
 666:stk500boot.c  **** }
 378               		.loc 1 666 0
 379 01be DF91      		pop r29
 380 01c0 CF91      		pop r28
 381 01c2 1F91      		pop r17
 382 01c4 0895      		ret
 383               		.cfi_endproc
 384               	.LFE16:
 387               	SubBytes:
 388               	.LFB17:
 667:stk500boot.c  **** 
 668:stk500boot.c  **** // The SubBytes Function Substitutes the values in the
 669:stk500boot.c  **** // state matrix with values in an S-box.
 670:stk500boot.c  **** static void SubBytes(void)
 671:stk500boot.c  **** {
 389               		.loc 1 671 0
 390               		.cfi_startproc
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 395               	.LVL19:
 396 01c6 2091 0000 		lds r18,state
 397 01ca 3091 0000 		lds r19,state+1
 672:stk500boot.c  ****   unsigned char i, j;
 673:stk500boot.c  ****   for(i = 0; i < 4; ++i)
 674:stk500boot.c  ****   {
 675:stk500boot.c  ****     for(j = 0; j < 4; ++j)
 676:stk500boot.c  ****     {
 677:stk500boot.c  ****       (*state)[j][i] = getSBoxValue((*state)[j][i]);
 398               		.loc 1 677 0
 399 01ce 94E0      		ldi r25,lo8(4)
 400               	.LVL20:
 401               	.L18:
 671:stk500boot.c  ****   unsigned char i, j;
 402               		.loc 1 671 0
 403 01d0 D901      		movw r26,r18
 404 01d2 84E0      		ldi r24,lo8(4)
 405               	.LVL21:
 406               	.L19:
 407               	.LBB62:
 408               	.LBB63:
 563:stk500boot.c  **** }
 409               		.loc 1 563 0 discriminator 3
 410 01d4 EC91      		ld r30,X
 411 01d6 F0E0      		ldi r31,0
 412 01d8 E050      		subi r30,lo8(-(sbox))
 413 01da F040      		sbci r31,hi8(-(sbox))
 414               	.LBE63:
 415               	.LBE62:
 416               		.loc 1 677 0 discriminator 3
 417 01dc 4081      		ld r20,Z
 418 01de 4C93      		st X,r20
 419               	.LVL22:
 420 01e0 8150      		subi r24,lo8(-(-1))
 421               	.LVL23:
 422 01e2 1496      		adiw r26,4
 675:stk500boot.c  ****     {
 423               		.loc 1 675 0 discriminator 3
 424 01e4 8111      		cpse r24,__zero_reg__
 425 01e6 00C0      		rjmp .L19
 426               	.LVL24:
 427 01e8 9150      		subi r25,lo8(-(-1))
 428 01ea 2F5F      		subi r18,-1
 429 01ec 3F4F      		sbci r19,-1
 430               	.LVL25:
 673:stk500boot.c  ****   {
 431               		.loc 1 673 0 discriminator 2
 432 01ee 9111      		cpse r25,__zero_reg__
 433 01f0 00C0      		rjmp .L18
 434               	/* epilogue start */
 678:stk500boot.c  ****     }
 679:stk500boot.c  ****   }
 680:stk500boot.c  **** }
 435               		.loc 1 680 0
 436 01f2 0895      		ret
 437               		.cfi_endproc
 438               	.LFE17:
 441               	ShiftRows:
 442               	.LFB18:
 681:stk500boot.c  **** 
 682:stk500boot.c  **** // The ShiftRows() function shifts the rows in the state to the left.
 683:stk500boot.c  **** // Each row is shifted with different offset.
 684:stk500boot.c  **** // Offset = Row number. So the first row is not shifted.
 685:stk500boot.c  **** static void ShiftRows(void)
 686:stk500boot.c  **** {
 443               		.loc 1 686 0
 444               		.cfi_startproc
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 0 */
 448               	.L__stack_usage = 0
 687:stk500boot.c  ****   unsigned char temp;
 688:stk500boot.c  **** 
 689:stk500boot.c  ****   // Rotate first row 1 columns to left
 690:stk500boot.c  ****   temp           = (*state)[0][1];
 449               		.loc 1 690 0
 450 01f4 E091 0000 		lds r30,state
 451 01f8 F091 0000 		lds r31,state+1
 452 01fc 8181      		ldd r24,Z+1
 453               	.LVL26:
 691:stk500boot.c  ****   (*state)[0][1] = (*state)[1][1];
 454               		.loc 1 691 0
 455 01fe 9581      		ldd r25,Z+5
 456 0200 9183      		std Z+1,r25
 692:stk500boot.c  ****   (*state)[1][1] = (*state)[2][1];
 457               		.loc 1 692 0
 458 0202 9185      		ldd r25,Z+9
 459 0204 9583      		std Z+5,r25
 693:stk500boot.c  ****   (*state)[2][1] = (*state)[3][1];
 460               		.loc 1 693 0
 461 0206 9585      		ldd r25,Z+13
 462 0208 9187      		std Z+9,r25
 694:stk500boot.c  ****   (*state)[3][1] = temp;
 463               		.loc 1 694 0
 464 020a 8587      		std Z+13,r24
 695:stk500boot.c  **** 
 696:stk500boot.c  ****   // Rotate second row 2 columns to left
 697:stk500boot.c  ****   temp           = (*state)[0][2];
 465               		.loc 1 697 0
 466 020c 8281      		ldd r24,Z+2
 467               	.LVL27:
 698:stk500boot.c  ****   (*state)[0][2] = (*state)[2][2];
 468               		.loc 1 698 0
 469 020e 9285      		ldd r25,Z+10
 470 0210 9283      		std Z+2,r25
 699:stk500boot.c  ****   (*state)[2][2] = temp;
 471               		.loc 1 699 0
 472 0212 8287      		std Z+10,r24
 700:stk500boot.c  **** 
 701:stk500boot.c  ****   temp       = (*state)[1][2];
 473               		.loc 1 701 0
 474 0214 8681      		ldd r24,Z+6
 475               	.LVL28:
 702:stk500boot.c  ****   (*state)[1][2] = (*state)[3][2];
 476               		.loc 1 702 0
 477 0216 9685      		ldd r25,Z+14
 478 0218 9683      		std Z+6,r25
 703:stk500boot.c  ****   (*state)[3][2] = temp;
 479               		.loc 1 703 0
 480 021a 8687      		std Z+14,r24
 704:stk500boot.c  **** 
 705:stk500boot.c  ****   // Rotate third row 3 columns to left
 706:stk500boot.c  ****   temp       = (*state)[0][3];
 481               		.loc 1 706 0
 482 021c 8381      		ldd r24,Z+3
 483               	.LVL29:
 707:stk500boot.c  ****   (*state)[0][3] = (*state)[3][3];
 484               		.loc 1 707 0
 485 021e 9785      		ldd r25,Z+15
 486 0220 9383      		std Z+3,r25
 708:stk500boot.c  ****   (*state)[3][3] = (*state)[2][3];
 487               		.loc 1 708 0
 488 0222 9385      		ldd r25,Z+11
 489 0224 9787      		std Z+15,r25
 709:stk500boot.c  ****   (*state)[2][3] = (*state)[1][3];
 490               		.loc 1 709 0
 491 0226 9781      		ldd r25,Z+7
 492 0228 9387      		std Z+11,r25
 710:stk500boot.c  ****   (*state)[1][3] = temp;
 493               		.loc 1 710 0
 494 022a 8783      		std Z+7,r24
 495               	/* epilogue start */
 711:stk500boot.c  **** }
 496               		.loc 1 711 0
 497 022c 0895      		ret
 498               		.cfi_endproc
 499               	.LFE18:
 502               	xtime:
 503               	.LFB19:
 712:stk500boot.c  **** 
 713:stk500boot.c  **** static unsigned char xtime(unsigned char x)
 714:stk500boot.c  **** {
 504               		.loc 1 714 0
 505               		.cfi_startproc
 506               	.LVL30:
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 0 */
 510               	.L__stack_usage = 0
 715:stk500boot.c  ****   return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
 511               		.loc 1 715 0
 512 022e 982F      		mov r25,r24
 513 0230 991F      		rol r25
 514 0232 9927      		clr r25
 515 0234 991F      		rol r25
 516 0236 2BE1      		ldi r18,lo8(27)
 517 0238 929F      		mul r25,r18
 518 023a 902D      		mov r25,r0
 519 023c 1124      		clr r1
 520 023e 880F      		lsl r24
 521               	.LVL31:
 716:stk500boot.c  **** }
 522               		.loc 1 716 0
 523 0240 8927      		eor r24,r25
 524               	/* epilogue start */
 525 0242 0895      		ret
 526               		.cfi_endproc
 527               	.LFE19:
 530               	InvSubBytes:
 531               	.LFB22:
 717:stk500boot.c  **** 
 718:stk500boot.c  **** // MixColumns function mixes the columns of the state matrix
 719:stk500boot.c  **** static void MixColumns(void)
 720:stk500boot.c  **** {
 721:stk500boot.c  ****   unsigned char i;
 722:stk500boot.c  ****   unsigned char Tmp,Tm,t;
 723:stk500boot.c  ****   for(i = 0; i < 4; ++i)
 724:stk500boot.c  ****   {
 725:stk500boot.c  ****     t   = (*state)[i][0];
 726:stk500boot.c  ****     Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
 727:stk500boot.c  ****     Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
 728:stk500boot.c  ****     Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
 729:stk500boot.c  ****     Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
 730:stk500boot.c  ****     Tm  = (*state)[i][3] ^ t ;        Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
 731:stk500boot.c  ****   }
 732:stk500boot.c  **** }
 733:stk500boot.c  **** 
 734:stk500boot.c  **** // Multiply is used to multiply numbers in the field GF(2^8)
 735:stk500boot.c  **** #if MULTIPLY_AS_A_FUNCTION
 736:stk500boot.c  **** static unsigned char Multiply(unsigned char x, unsigned char y)
 737:stk500boot.c  **** {
 738:stk500boot.c  ****   return (((y & 1) * x) ^
 739:stk500boot.c  ****        ((y>>1 & 1) * xtime(x)) ^
 740:stk500boot.c  ****        ((y>>2 & 1) * xtime(xtime(x))) ^
 741:stk500boot.c  ****        ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^
 742:stk500boot.c  ****        ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))));
 743:stk500boot.c  ****   }
 744:stk500boot.c  **** #else
 745:stk500boot.c  **** #define Multiply(x, y)                                \
 746:stk500boot.c  ****       (  ((y & 1) * x) ^                              \
 747:stk500boot.c  ****       ((y>>1 & 1) * xtime(x)) ^                       \
 748:stk500boot.c  ****       ((y>>2 & 1) * xtime(xtime(x))) ^                \
 749:stk500boot.c  ****       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
 750:stk500boot.c  ****       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \
 751:stk500boot.c  **** 
 752:stk500boot.c  **** #endif
 753:stk500boot.c  **** 
 754:stk500boot.c  **** // MixColumns function mixes the columns of the state matrix.
 755:stk500boot.c  **** // The method used to multiply may be difficult to understand for the inexperienced.
 756:stk500boot.c  **** // Please use the references to gain more information.
 757:stk500boot.c  **** static void InvMixColumns(void)
 758:stk500boot.c  **** {
 759:stk500boot.c  ****   int i;
 760:stk500boot.c  ****   unsigned char a,b,c,d;
 761:stk500boot.c  ****   for(i=0;i<4;++i)
 762:stk500boot.c  ****   {
 763:stk500boot.c  ****     a = (*state)[i][0];
 764:stk500boot.c  ****     b = (*state)[i][1];
 765:stk500boot.c  ****     c = (*state)[i][2];
 766:stk500boot.c  ****     d = (*state)[i][3];
 767:stk500boot.c  **** 
 768:stk500boot.c  ****     (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
 769:stk500boot.c  ****     (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
 770:stk500boot.c  ****     (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
 771:stk500boot.c  ****     (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
 772:stk500boot.c  ****   }
 773:stk500boot.c  **** }
 774:stk500boot.c  **** 
 775:stk500boot.c  **** 
 776:stk500boot.c  **** // The SubBytes Function Substitutes the values in the
 777:stk500boot.c  **** // state matrix with values in an S-box.
 778:stk500boot.c  **** static void InvSubBytes(void)
 779:stk500boot.c  **** {
 532               		.loc 1 779 0
 533               		.cfi_startproc
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 0 */
 537               	.L__stack_usage = 0
 538               	.LVL32:
 539 0244 2091 0000 		lds r18,state
 540 0248 3091 0000 		lds r19,state+1
 780:stk500boot.c  ****   unsigned char i,j;
 781:stk500boot.c  ****   for(i=0;i<4;++i)
 782:stk500boot.c  ****   {
 783:stk500boot.c  ****     for(j=0;j<4;++j)
 784:stk500boot.c  ****     {
 785:stk500boot.c  ****       (*state)[j][i] = getSBoxInvert((*state)[j][i]);
 541               		.loc 1 785 0
 542 024c 94E0      		ldi r25,lo8(4)
 543               	.LVL33:
 544               	.L25:
 779:stk500boot.c  ****   unsigned char i,j;
 545               		.loc 1 779 0
 546 024e D901      		movw r26,r18
 547 0250 84E0      		ldi r24,lo8(4)
 548               	.LVL34:
 549               	.L26:
 550               	.LBB64:
 551               	.LBB65:
 568:stk500boot.c  **** }
 552               		.loc 1 568 0 discriminator 3
 553 0252 EC91      		ld r30,X
 554 0254 F0E0      		ldi r31,0
 555 0256 E050      		subi r30,lo8(-(rsbox))
 556 0258 F040      		sbci r31,hi8(-(rsbox))
 557               	.LBE65:
 558               	.LBE64:
 559               		.loc 1 785 0 discriminator 3
 560 025a 4081      		ld r20,Z
 561 025c 4C93      		st X,r20
 562               	.LVL35:
 563 025e 8150      		subi r24,lo8(-(-1))
 564               	.LVL36:
 565 0260 1496      		adiw r26,4
 783:stk500boot.c  ****     {
 566               		.loc 1 783 0 discriminator 3
 567 0262 8111      		cpse r24,__zero_reg__
 568 0264 00C0      		rjmp .L26
 569               	.LVL37:
 570 0266 9150      		subi r25,lo8(-(-1))
 571 0268 2F5F      		subi r18,-1
 572 026a 3F4F      		sbci r19,-1
 573               	.LVL38:
 781:stk500boot.c  ****   {
 574               		.loc 1 781 0 discriminator 2
 575 026c 9111      		cpse r25,__zero_reg__
 576 026e 00C0      		rjmp .L25
 577               	/* epilogue start */
 786:stk500boot.c  ****     }
 787:stk500boot.c  ****   }
 788:stk500boot.c  **** }
 578               		.loc 1 788 0
 579 0270 0895      		ret
 580               		.cfi_endproc
 581               	.LFE22:
 584               	InvShiftRows:
 585               	.LFB23:
 789:stk500boot.c  **** 
 790:stk500boot.c  **** static void InvShiftRows(void)
 791:stk500boot.c  **** {
 586               		.loc 1 791 0
 587               		.cfi_startproc
 588               	/* prologue: function */
 589               	/* frame size = 0 */
 590               	/* stack size = 0 */
 591               	.L__stack_usage = 0
 792:stk500boot.c  ****   unsigned char temp;
 793:stk500boot.c  **** 
 794:stk500boot.c  ****   // Rotate first row 1 columns to right
 795:stk500boot.c  ****   temp=(*state)[3][1];
 592               		.loc 1 795 0
 593 0272 E091 0000 		lds r30,state
 594 0276 F091 0000 		lds r31,state+1
 595 027a 8585      		ldd r24,Z+13
 596               	.LVL39:
 796:stk500boot.c  ****   (*state)[3][1]=(*state)[2][1];
 597               		.loc 1 796 0
 598 027c 9185      		ldd r25,Z+9
 599 027e 9587      		std Z+13,r25
 797:stk500boot.c  ****   (*state)[2][1]=(*state)[1][1];
 600               		.loc 1 797 0
 601 0280 9581      		ldd r25,Z+5
 602 0282 9187      		std Z+9,r25
 798:stk500boot.c  ****   (*state)[1][1]=(*state)[0][1];
 603               		.loc 1 798 0
 604 0284 9181      		ldd r25,Z+1
 605 0286 9583      		std Z+5,r25
 799:stk500boot.c  ****   (*state)[0][1]=temp;
 606               		.loc 1 799 0
 607 0288 8183      		std Z+1,r24
 800:stk500boot.c  **** 
 801:stk500boot.c  ****   // Rotate second row 2 columns to right
 802:stk500boot.c  ****   temp=(*state)[0][2];
 608               		.loc 1 802 0
 609 028a 8281      		ldd r24,Z+2
 610               	.LVL40:
 803:stk500boot.c  ****   (*state)[0][2]=(*state)[2][2];
 611               		.loc 1 803 0
 612 028c 9285      		ldd r25,Z+10
 613 028e 9283      		std Z+2,r25
 804:stk500boot.c  ****   (*state)[2][2]=temp;
 614               		.loc 1 804 0
 615 0290 8287      		std Z+10,r24
 805:stk500boot.c  **** 
 806:stk500boot.c  ****   temp=(*state)[1][2];
 616               		.loc 1 806 0
 617 0292 8681      		ldd r24,Z+6
 618               	.LVL41:
 807:stk500boot.c  ****   (*state)[1][2]=(*state)[3][2];
 619               		.loc 1 807 0
 620 0294 9685      		ldd r25,Z+14
 621 0296 9683      		std Z+6,r25
 808:stk500boot.c  ****   (*state)[3][2]=temp;
 622               		.loc 1 808 0
 623 0298 8687      		std Z+14,r24
 809:stk500boot.c  **** 
 810:stk500boot.c  ****   // Rotate third row 3 columns to right
 811:stk500boot.c  ****   temp=(*state)[0][3];
 624               		.loc 1 811 0
 625 029a 8381      		ldd r24,Z+3
 626               	.LVL42:
 812:stk500boot.c  ****   (*state)[0][3]=(*state)[1][3];
 627               		.loc 1 812 0
 628 029c 9781      		ldd r25,Z+7
 629 029e 9383      		std Z+3,r25
 813:stk500boot.c  ****   (*state)[1][3]=(*state)[2][3];
 630               		.loc 1 813 0
 631 02a0 9385      		ldd r25,Z+11
 632 02a2 9783      		std Z+7,r25
 814:stk500boot.c  ****   (*state)[2][3]=(*state)[3][3];
 633               		.loc 1 814 0
 634 02a4 9785      		ldd r25,Z+15
 635 02a6 9387      		std Z+11,r25
 815:stk500boot.c  ****   (*state)[3][3]=temp;
 636               		.loc 1 815 0
 637 02a8 8787      		std Z+15,r24
 638               	/* epilogue start */
 816:stk500boot.c  **** }
 639               		.loc 1 816 0
 640 02aa 0895      		ret
 641               		.cfi_endproc
 642               	.LFE23:
 645               	Cipher:
 646               	.LFB24:
 817:stk500boot.c  **** 
 818:stk500boot.c  **** 
 819:stk500boot.c  **** // Cipher is the main function that encrypts the PlainText.
 820:stk500boot.c  **** static void Cipher(void)
 821:stk500boot.c  **** {
 647               		.loc 1 821 0
 648               		.cfi_startproc
 649 02ac 9F92      		push r9
 650               	.LCFI14:
 651               		.cfi_def_cfa_offset 4
 652               		.cfi_offset 9, -3
 653 02ae AF92      		push r10
 654               	.LCFI15:
 655               		.cfi_def_cfa_offset 5
 656               		.cfi_offset 10, -4
 657 02b0 BF92      		push r11
 658               	.LCFI16:
 659               		.cfi_def_cfa_offset 6
 660               		.cfi_offset 11, -5
 661 02b2 CF92      		push r12
 662               	.LCFI17:
 663               		.cfi_def_cfa_offset 7
 664               		.cfi_offset 12, -6
 665 02b4 DF92      		push r13
 666               	.LCFI18:
 667               		.cfi_def_cfa_offset 8
 668               		.cfi_offset 13, -7
 669 02b6 EF92      		push r14
 670               	.LCFI19:
 671               		.cfi_def_cfa_offset 9
 672               		.cfi_offset 14, -8
 673 02b8 FF92      		push r15
 674               	.LCFI20:
 675               		.cfi_def_cfa_offset 10
 676               		.cfi_offset 15, -9
 677 02ba 0F93      		push r16
 678               	.LCFI21:
 679               		.cfi_def_cfa_offset 11
 680               		.cfi_offset 16, -10
 681 02bc 1F93      		push r17
 682               	.LCFI22:
 683               		.cfi_def_cfa_offset 12
 684               		.cfi_offset 17, -11
 685 02be CF93      		push r28
 686               	.LCFI23:
 687               		.cfi_def_cfa_offset 13
 688               		.cfi_offset 28, -12
 689 02c0 DF93      		push r29
 690               	.LCFI24:
 691               		.cfi_def_cfa_offset 14
 692               		.cfi_offset 29, -13
 693               	/* prologue: function */
 694               	/* frame size = 0 */
 695               	/* stack size = 11 */
 696               	.L__stack_usage = 11
 697               	.LVL43:
 822:stk500boot.c  ****   unsigned char round = 0;
 823:stk500boot.c  **** 
 824:stk500boot.c  ****   // Add the First round key to the state before starting the rounds.
 825:stk500boot.c  ****   AddRoundKey(0);
 698               		.loc 1 825 0
 699 02c2 80E0      		ldi r24,0
 700 02c4 0E94 0000 		call AddRoundKey
 701               	.LVL44:
 826:stk500boot.c  **** 
 827:stk500boot.c  ****   // There will be Nr rounds.
 828:stk500boot.c  ****   // The first Nr-1 rounds are identical.
 829:stk500boot.c  ****   // These Nr-1 rounds are executed in the loop below.
 830:stk500boot.c  ****   for(round = 1; round < Nr; ++round)
 702               		.loc 1 830 0
 703 02c8 CC24      		clr r12
 704 02ca C394      		inc r12
 705               	.LVL45:
 706               	.L32:
 831:stk500boot.c  ****   {
 832:stk500boot.c  ****     SubBytes();
 707               		.loc 1 832 0 discriminator 3
 708 02cc 0E94 0000 		call SubBytes
 709               	.LVL46:
 833:stk500boot.c  ****     ShiftRows();
 710               		.loc 1 833 0 discriminator 3
 711 02d0 0E94 0000 		call ShiftRows
 712               	.LVL47:
 713 02d4 C091 0000 		lds r28,state
 714 02d8 D091 0000 		lds r29,state+1
 715 02dc 7E01      		movw r14,r28
 716 02de 80E1      		ldi r24,16
 717 02e0 E80E      		add r14,r24
 718 02e2 F11C      		adc r15,__zero_reg__
 719               	.LVL48:
 720               	.L31:
 721               	.LBB68:
 722               	.LBB69:
 725:stk500boot.c  ****     Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
 723               		.loc 1 725 0
 724 02e4 A880      		ld r10,Y
 725               	.LVL49:
 726:stk500boot.c  ****     Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
 726               		.loc 1 726 0
 727 02e6 D980      		ldd r13,Y+1
 728 02e8 8A2D      		mov r24,r10
 729 02ea 8D25      		eor r24,r13
 730 02ec 0A81      		ldd r16,Y+2
 731 02ee 1B81      		ldd r17,Y+3
 732 02f0 902E      		mov r9,r16
 733 02f2 9126      		eor r9,r17
 734 02f4 B82E      		mov r11,r24
 735 02f6 B924      		eor r11,r9
 736               	.LVL50:
 727:stk500boot.c  ****     Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
 737               		.loc 1 727 0
 738 02f8 0E94 0000 		call xtime
 739               	.LVL51:
 740 02fc 8A25      		eor r24,r10
 741               	.LVL52:
 742 02fe 8B25      		eor r24,r11
 743 0300 8883      		st Y,r24
 744               	.LVL53:
 728:stk500boot.c  ****     Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
 745               		.loc 1 728 0
 746 0302 8D2D      		mov r24,r13
 747 0304 8027      		eor r24,r16
 748               	.LVL54:
 749 0306 0E94 0000 		call xtime
 750               	.LVL55:
 751 030a 8D25      		eor r24,r13
 752               	.LVL56:
 753 030c 8B25      		eor r24,r11
 754 030e 8983      		std Y+1,r24
 755               	.LVL57:
 729:stk500boot.c  ****     Tm  = (*state)[i][3] ^ t ;        Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
 756               		.loc 1 729 0
 757 0310 892D      		mov r24,r9
 758 0312 0E94 0000 		call xtime
 759               	.LVL58:
 760 0316 8027      		eor r24,r16
 761               	.LVL59:
 762 0318 8B25      		eor r24,r11
 763 031a 8A83      		std Y+2,r24
 764               	.LVL60:
 730:stk500boot.c  ****   }
 765               		.loc 1 730 0
 766 031c 8A2D      		mov r24,r10
 767 031e 8127      		eor r24,r17
 768               	.LVL61:
 769 0320 0E94 0000 		call xtime
 770               	.LVL62:
 771 0324 8127      		eor r24,r17
 772               	.LVL63:
 773 0326 8B25      		eor r24,r11
 774 0328 8B83      		std Y+3,r24
 775 032a 2496      		adiw r28,4
 723:stk500boot.c  ****   {
 776               		.loc 1 723 0
 777 032c CE15      		cp r28,r14
 778 032e DF05      		cpc r29,r15
 779 0330 01F4      		brne .L31
 780               	.LVL64:
 781               	.LBE69:
 782               	.LBE68:
 834:stk500boot.c  ****     MixColumns();
 835:stk500boot.c  ****     AddRoundKey(round);
 783               		.loc 1 835 0 discriminator 3
 784 0332 8C2D      		mov r24,r12
 785 0334 0E94 0000 		call AddRoundKey
 786               	.LVL65:
 830:stk500boot.c  ****   {
 787               		.loc 1 830 0 discriminator 3
 788 0338 C394      		inc r12
 789               	.LVL66:
 790 033a 8AE0      		ldi r24,lo8(10)
 791 033c C812      		cpse r12,r24
 792 033e 00C0      		rjmp .L32
 836:stk500boot.c  ****   }
 837:stk500boot.c  **** 
 838:stk500boot.c  ****   // The last round is given below.
 839:stk500boot.c  ****   // The MixColumns function is not here in the last round.
 840:stk500boot.c  ****   SubBytes();
 793               		.loc 1 840 0
 794 0340 0E94 0000 		call SubBytes
 795               	.LVL67:
 841:stk500boot.c  ****   ShiftRows();
 796               		.loc 1 841 0
 797 0344 0E94 0000 		call ShiftRows
 798               	.LVL68:
 842:stk500boot.c  ****   AddRoundKey(Nr);
 799               		.loc 1 842 0
 800 0348 8AE0      		ldi r24,lo8(10)
 801               	/* epilogue start */
 843:stk500boot.c  **** }
 802               		.loc 1 843 0
 803 034a DF91      		pop r29
 804 034c CF91      		pop r28
 805 034e 1F91      		pop r17
 806 0350 0F91      		pop r16
 807 0352 FF90      		pop r15
 808 0354 EF90      		pop r14
 809 0356 DF90      		pop r13
 810 0358 CF90      		pop r12
 811               	.LVL69:
 812 035a BF90      		pop r11
 813 035c AF90      		pop r10
 814 035e 9F90      		pop r9
 842:stk500boot.c  ****   AddRoundKey(Nr);
 815               		.loc 1 842 0
 816 0360 0C94 0000 		jmp AddRoundKey
 817               	.LVL70:
 818               		.cfi_endproc
 819               	.LFE24:
 822               	InvCipher:
 823               	.LFB25:
 844:stk500boot.c  **** 
 845:stk500boot.c  **** static void InvCipher(void)
 846:stk500boot.c  **** {
 824               		.loc 1 846 0
 825               		.cfi_startproc
 826 0364 2F92      		push r2
 827               	.LCFI25:
 828               		.cfi_def_cfa_offset 4
 829               		.cfi_offset 2, -3
 830 0366 3F92      		push r3
 831               	.LCFI26:
 832               		.cfi_def_cfa_offset 5
 833               		.cfi_offset 3, -4
 834 0368 4F92      		push r4
 835               	.LCFI27:
 836               		.cfi_def_cfa_offset 6
 837               		.cfi_offset 4, -5
 838 036a 5F92      		push r5
 839               	.LCFI28:
 840               		.cfi_def_cfa_offset 7
 841               		.cfi_offset 5, -6
 842 036c 6F92      		push r6
 843               	.LCFI29:
 844               		.cfi_def_cfa_offset 8
 845               		.cfi_offset 6, -7
 846 036e 7F92      		push r7
 847               	.LCFI30:
 848               		.cfi_def_cfa_offset 9
 849               		.cfi_offset 7, -8
 850 0370 8F92      		push r8
 851               	.LCFI31:
 852               		.cfi_def_cfa_offset 10
 853               		.cfi_offset 8, -9
 854 0372 9F92      		push r9
 855               	.LCFI32:
 856               		.cfi_def_cfa_offset 11
 857               		.cfi_offset 9, -10
 858 0374 AF92      		push r10
 859               	.LCFI33:
 860               		.cfi_def_cfa_offset 12
 861               		.cfi_offset 10, -11
 862 0376 BF92      		push r11
 863               	.LCFI34:
 864               		.cfi_def_cfa_offset 13
 865               		.cfi_offset 11, -12
 866 0378 CF92      		push r12
 867               	.LCFI35:
 868               		.cfi_def_cfa_offset 14
 869               		.cfi_offset 12, -13
 870 037a DF92      		push r13
 871               	.LCFI36:
 872               		.cfi_def_cfa_offset 15
 873               		.cfi_offset 13, -14
 874 037c EF92      		push r14
 875               	.LCFI37:
 876               		.cfi_def_cfa_offset 16
 877               		.cfi_offset 14, -15
 878 037e FF92      		push r15
 879               	.LCFI38:
 880               		.cfi_def_cfa_offset 17
 881               		.cfi_offset 15, -16
 882 0380 0F93      		push r16
 883               	.LCFI39:
 884               		.cfi_def_cfa_offset 18
 885               		.cfi_offset 16, -17
 886 0382 1F93      		push r17
 887               	.LCFI40:
 888               		.cfi_def_cfa_offset 19
 889               		.cfi_offset 17, -18
 890 0384 CF93      		push r28
 891               	.LCFI41:
 892               		.cfi_def_cfa_offset 20
 893               		.cfi_offset 28, -19
 894 0386 DF93      		push r29
 895               	.LCFI42:
 896               		.cfi_def_cfa_offset 21
 897               		.cfi_offset 29, -20
 898 0388 00D0      		rcall .
 899 038a 1F92      		push __zero_reg__
 900               	.LCFI43:
 901               		.cfi_def_cfa_offset 25
 902 038c CDB7      		in r28,__SP_L__
 903 038e DEB7      		in r29,__SP_H__
 904               	.LCFI44:
 905               		.cfi_def_cfa_register 28
 906               	/* prologue: function */
 907               	/* frame size = 4 */
 908               	/* stack size = 22 */
 909               	.L__stack_usage = 22
 910               	.LVL71:
 847:stk500boot.c  ****   unsigned char round=0;
 848:stk500boot.c  **** 
 849:stk500boot.c  ****   // Add the First round key to the state before starting the rounds.
 850:stk500boot.c  ****   AddRoundKey(Nr);
 911               		.loc 1 850 0
 912 0390 8AE0      		ldi r24,lo8(10)
 913 0392 0E94 0000 		call AddRoundKey
 914               	.LVL72:
 851:stk500boot.c  **** 
 852:stk500boot.c  ****   // There will be Nr rounds.
 853:stk500boot.c  ****   // The first Nr-1 rounds are identical.
 854:stk500boot.c  ****   // These Nr-1 rounds are executed in the loop below.
 855:stk500boot.c  ****   for(round=Nr-1;round>0;round--)
 915               		.loc 1 855 0
 916 0396 09E0      		ldi r16,lo8(9)
 917               	.LVL73:
 918               	.L37:
 856:stk500boot.c  ****   {
 857:stk500boot.c  ****     InvShiftRows();
 919               		.loc 1 857 0 discriminator 3
 920 0398 0E94 0000 		call InvShiftRows
 921               	.LVL74:
 858:stk500boot.c  ****     InvSubBytes();
 922               		.loc 1 858 0 discriminator 3
 923 039c 0E94 0000 		call InvSubBytes
 924               	.LVL75:
 859:stk500boot.c  ****     AddRoundKey(round);
 925               		.loc 1 859 0 discriminator 3
 926 03a0 802F      		mov r24,r16
 927 03a2 0E94 0000 		call AddRoundKey
 928               	.LVL76:
 929 03a6 E090 0000 		lds r14,state
 930 03aa F090 0000 		lds r15,state+1
 931 03ae C701      		movw r24,r14
 932 03b0 4096      		adiw r24,16
 933 03b2 9A83      		std Y+2,r25
 934 03b4 8983      		std Y+1,r24
 935               	.LVL77:
 936               	.L36:
 937               	.LBB72:
 938               	.LBB73:
 763:stk500boot.c  ****     b = (*state)[i][1];
 939               		.loc 1 763 0
 940 03b6 F701      		movw r30,r14
 941 03b8 B080      		ld r11,Z
 942               	.LVL78:
 764:stk500boot.c  ****     c = (*state)[i][2];
 943               		.loc 1 764 0
 944 03ba C180      		ldd r12,Z+1
 945               	.LVL79:
 765:stk500boot.c  ****     d = (*state)[i][3];
 946               		.loc 1 765 0
 947 03bc D280      		ldd r13,Z+2
 948               	.LVL80:
 766:stk500boot.c  **** 
 949               		.loc 1 766 0
 950 03be 7380      		ldd r7,Z+3
 951               	.LVL81:
 768:stk500boot.c  ****     (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
 952               		.loc 1 768 0
 953 03c0 8B2D      		mov r24,r11
 954 03c2 0E94 0000 		call xtime
 955               	.LVL82:
 956 03c6 8B83      		std Y+3,r24
 957 03c8 0E94 0000 		call xtime
 958               	.LVL83:
 959 03cc 8C83      		std Y+4,r24
 960 03ce 0E94 0000 		call xtime
 961               	.LVL84:
 962 03d2 882E      		mov r8,r24
 963 03d4 8C2D      		mov r24,r12
 964 03d6 0E94 0000 		call xtime
 965               	.LVL85:
 966 03da 182F      		mov r17,r24
 967 03dc 0E94 0000 		call xtime
 968               	.LVL86:
 969 03e0 482E      		mov r4,r24
 970 03e2 0E94 0000 		call xtime
 971               	.LVL87:
 972 03e6 982E      		mov r9,r24
 973 03e8 8D2D      		mov r24,r13
 974 03ea 0E94 0000 		call xtime
 975               	.LVL88:
 976 03ee 282E      		mov r2,r24
 977 03f0 0E94 0000 		call xtime
 978               	.LVL89:
 979 03f4 382E      		mov r3,r24
 980 03f6 0E94 0000 		call xtime
 981               	.LVL90:
 982 03fa A82E      		mov r10,r24
 983 03fc 872D      		mov r24,r7
 984 03fe 0E94 0000 		call xtime
 985               	.LVL91:
 986 0402 582E      		mov r5,r24
 987 0404 0E94 0000 		call xtime
 988               	.LVL92:
 989 0408 682E      		mov r6,r24
 990 040a 0E94 0000 		call xtime
 991               	.LVL93:
 992 040e 9B81      		ldd r25,Y+3
 993 0410 FC81      		ldd r31,Y+4
 994 0412 9F27      		eor r25,r31
 995 0414 9825      		eor r25,r8
 996 0416 9127      		eor r25,r17
 997 0418 9925      		eor r25,r9
 998 041a 9325      		eor r25,r3
 999 041c 9A25      		eor r25,r10
 1000 041e 9827      		eor r25,r24
 1001 0420 9C25      		eor r25,r12
 1002 0422 9D25      		eor r25,r13
 1003 0424 9725      		eor r25,r7
 1004 0426 F701      		movw r30,r14
 1005 0428 9083      		st Z,r25
 769:stk500boot.c  ****     (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
 1006               		.loc 1 769 0
 1007 042a 982D      		mov r25,r8
 1008 042c 9127      		eor r25,r17
 1009 042e 9425      		eor r25,r4
 1010 0430 9925      		eor r25,r9
 1011 0432 9225      		eor r25,r2
 1012 0434 9A25      		eor r25,r10
 1013 0436 9625      		eor r25,r6
 1014 0438 9827      		eor r25,r24
 1015 043a 9B25      		eor r25,r11
 1016 043c 9D25      		eor r25,r13
 1017 043e 9725      		eor r25,r7
 1018 0440 9183      		std Z+1,r25
 770:stk500boot.c  ****     (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
 1019               		.loc 1 770 0
 1020 0442 FC81      		ldd r31,Y+4
 1021 0444 F825      		eor r31,r8
 1022 0446 F925      		eor r31,r9
 1023 0448 2F26      		eor r2,r31
 1024 044a 3224      		eor r3,r2
 1025 044c 3A24      		eor r3,r10
 1026 044e 3524      		eor r3,r5
 1027 0450 3826      		eor r3,r24
 1028 0452 3B24      		eor r3,r11
 1029 0454 3C24      		eor r3,r12
 1030 0456 7324      		eor r7,r3
 1031               	.LVL94:
 1032 0458 F701      		movw r30,r14
 1033 045a 7282      		std Z+2,r7
 771:stk500boot.c  ****   }
 1034               		.loc 1 771 0
 1035 045c FB81      		ldd r31,Y+3
 1036 045e F825      		eor r31,r8
 1037 0460 4F26      		eor r4,r31
 1038 0462 9424      		eor r9,r4
 1039 0464 A924      		eor r10,r9
 1040 0466 5A24      		eor r5,r10
 1041 0468 6524      		eor r6,r5
 1042 046a 8625      		eor r24,r6
 1043 046c B826      		eor r11,r24
 1044               	.LVL95:
 1045 046e CB24      		eor r12,r11
 1046               	.LVL96:
 1047 0470 DC24      		eor r13,r12
 1048               	.LVL97:
 1049 0472 F701      		movw r30,r14
 1050 0474 D382      		std Z+3,r13
 1051 0476 F4E0      		ldi r31,4
 1052 0478 EF0E      		add r14,r31
 1053 047a F11C      		adc r15,__zero_reg__
 761:stk500boot.c  ****   {
 1054               		.loc 1 761 0
 1055 047c 8981      		ldd r24,Y+1
 1056 047e 9A81      		ldd r25,Y+2
 1057 0480 8E15      		cp r24,r14
 1058 0482 9F05      		cpc r25,r15
 1059 0484 01F0      		breq .+2
 1060 0486 00C0      		rjmp .L36
 1061               	.LBE73:
 1062               	.LBE72:
 855:stk500boot.c  ****   {
 1063               		.loc 1 855 0 discriminator 3
 1064 0488 0150      		subi r16,lo8(-(-1))
 1065               	.LVL98:
 1066 048a 01F0      		breq .+2
 1067 048c 00C0      		rjmp .L37
 860:stk500boot.c  ****     InvMixColumns();
 861:stk500boot.c  ****   }
 862:stk500boot.c  **** 
 863:stk500boot.c  ****   // The last round is given below.
 864:stk500boot.c  ****   // The MixColumns function is not here in the last round.
 865:stk500boot.c  ****   InvShiftRows();
 1068               		.loc 1 865 0
 1069 048e 0E94 0000 		call InvShiftRows
 1070               	.LVL99:
 866:stk500boot.c  ****   InvSubBytes();
 1071               		.loc 1 866 0
 1072 0492 0E94 0000 		call InvSubBytes
 1073               	.LVL100:
 867:stk500boot.c  ****   AddRoundKey(0);
 1074               		.loc 1 867 0
 1075 0496 80E0      		ldi r24,0
 1076               	/* epilogue start */
 868:stk500boot.c  **** }
 1077               		.loc 1 868 0
 1078 0498 0F90      		pop __tmp_reg__
 1079 049a 0F90      		pop __tmp_reg__
 1080 049c 0F90      		pop __tmp_reg__
 1081 049e 0F90      		pop __tmp_reg__
 1082 04a0 DF91      		pop r29
 1083 04a2 CF91      		pop r28
 1084 04a4 1F91      		pop r17
 1085 04a6 0F91      		pop r16
 1086               	.LVL101:
 1087 04a8 FF90      		pop r15
 1088 04aa EF90      		pop r14
 1089 04ac DF90      		pop r13
 1090 04ae CF90      		pop r12
 1091 04b0 BF90      		pop r11
 1092 04b2 AF90      		pop r10
 1093 04b4 9F90      		pop r9
 1094 04b6 8F90      		pop r8
 1095 04b8 7F90      		pop r7
 1096 04ba 6F90      		pop r6
 1097 04bc 5F90      		pop r5
 1098 04be 4F90      		pop r4
 1099 04c0 3F90      		pop r3
 1100 04c2 2F90      		pop r2
 867:stk500boot.c  ****   AddRoundKey(0);
 1101               		.loc 1 867 0
 1102 04c4 0C94 0000 		jmp AddRoundKey
 1103               	.LVL102:
 1104               		.cfi_endproc
 1105               	.LFE25:
 1108               	sendchar:
 1109               	.LFB31:
 869:stk500boot.c  **** 
 870:stk500boot.c  **** static void BlockCopy(unsigned char* output, const unsigned char* input)
 871:stk500boot.c  **** {
 872:stk500boot.c  ****   unsigned char i;
 873:stk500boot.c  ****   for (i=0;i<16;++i)
 874:stk500boot.c  ****   {
 875:stk500boot.c  ****     output[i] = input[i];
 876:stk500boot.c  ****   }
 877:stk500boot.c  **** }
 878:stk500boot.c  **** static void aes_decrypt(unsigned char* output, unsigned char* input, unsigned int length)
 879:stk500boot.c  **** {
 880:stk500boot.c  **** 	uintptr_t i;
 881:stk500boot.c  ****   uint8_t extra = length % BLOCKLEN; /* Remaining bytes in the last non-full block */
 882:stk500boot.c  **** 
 883:stk500boot.c  ****   // Skip the key expansion if key is passed as 0
 884:stk500boot.c  ****   if (0 != key)
 885:stk500boot.c  ****   {
 886:stk500boot.c  ****     Key = key;
 887:stk500boot.c  ****     KeyExpansion();
 888:stk500boot.c  ****   }
 889:stk500boot.c  **** 
 890:stk500boot.c  ****   // If iv is passed as 0, we continue to encrypt without re-setting the Iv
 891:stk500boot.c  ****   if (iv != 0)
 892:stk500boot.c  ****   {
 893:stk500boot.c  ****     Iv = (uint8_t*)iv;
 894:stk500boot.c  ****   }
 895:stk500boot.c  **** 
 896:stk500boot.c  ****   for (i = 0; i < length; i += BLOCKLEN)
 897:stk500boot.c  ****   {
 898:stk500boot.c  ****     memcpy(output, input, BLOCKLEN);
 899:stk500boot.c  ****     state = (state_t*)output;
 900:stk500boot.c  ****     InvCipher();
 901:stk500boot.c  ****     XorWithIv(output);
 902:stk500boot.c  ****     Iv = input;
 903:stk500boot.c  ****     input += BLOCKLEN;
 904:stk500boot.c  ****     output += BLOCKLEN;
 905:stk500boot.c  ****   }
 906:stk500boot.c  **** 
 907:stk500boot.c  ****   if (extra)
 908:stk500boot.c  ****   {
 909:stk500boot.c  ****     memcpy(output, input, extra);
 910:stk500boot.c  ****     state = (state_t*)output;
 911:stk500boot.c  ****     InvCipher();
 912:stk500boot.c  ****   }
 913:stk500boot.c  **** }
 914:stk500boot.c  **** 
 915:stk500boot.c  **** static void aes_encrypt(unsigned char* output, unsigned char* input, unsigned int length){
 916:stk500boot.c  **** 	uintptr_t i;
 917:stk500boot.c  ****   uint8_t extra = length % 16; /* Remaining bytes in the last non-full block */
 918:stk500boot.c  **** 
 919:stk500boot.c  ****   // Skip the key expansion if key is passed as 0
 920:stk500boot.c  ****   if (0 != key)
 921:stk500boot.c  ****   {
 922:stk500boot.c  ****     Key = key;
 923:stk500boot.c  ****     KeyExpansion();
 924:stk500boot.c  ****   }
 925:stk500boot.c  **** 
 926:stk500boot.c  ****   if (iv != 0)
 927:stk500boot.c  ****   {
 928:stk500boot.c  ****     Iv = (uint8_t*)iv;
 929:stk500boot.c  ****   }
 930:stk500boot.c  **** 
 931:stk500boot.c  ****   for (i = 0; i < length; i += 16)
 932:stk500boot.c  ****   {
 933:stk500boot.c  ****     XorWithIv(input);
 934:stk500boot.c  ****     memcpy(output, input, 16);
 935:stk500boot.c  ****     state = (state_t*)output;
 936:stk500boot.c  ****     Cipher();
 937:stk500boot.c  ****     Iv = output;
 938:stk500boot.c  ****     input += 16;
 939:stk500boot.c  ****     output += 16;
 940:stk500boot.c  ****     //printf("Step %d - %d", i/16, i);
 941:stk500boot.c  ****   }
 942:stk500boot.c  **** 
 943:stk500boot.c  ****   if (extra)
 944:stk500boot.c  ****   {
 945:stk500boot.c  ****     memcpy(output, input, extra);
 946:stk500boot.c  ****     state = (state_t*)output;
 947:stk500boot.c  ****     Cipher();
 948:stk500boot.c  ****   }
 949:stk500boot.c  **** }
 950:stk500boot.c  **** 
 951:stk500boot.c  **** 
 952:stk500boot.c  **** //Burak
 953:stk500boot.c  **** /*
 954:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 955:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 956:stk500boot.c  ****  */
 957:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 958:stk500boot.c  **** #include <avr/sfr_defs.h>
 959:stk500boot.c  **** 
 960:stk500boot.c  **** //#define	SPH_REG	0x3E
 961:stk500boot.c  **** //#define	SPL_REG	0x3D
 962:stk500boot.c  **** 
 963:stk500boot.c  **** //*****************************************************************************
 964:stk500boot.c  **** void __jumpMain(void)
 965:stk500boot.c  **** {
 966:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 967:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 968:stk500boot.c  **** 
 969:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 970:stk500boot.c  **** 
 971:stk500boot.c  **** //*	set stack pointer to top of RAM
 972:stk500boot.c  **** 
 973:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 974:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 975:stk500boot.c  **** 
 976:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 977:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 978:stk500boot.c  **** 
 979:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 980:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 981:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 982:stk500boot.c  **** }
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 
 985:stk500boot.c  **** //*****************************************************************************
 986:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 987:stk500boot.c  **** {
 988:stk500boot.c  **** 	unsigned int i;
 989:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 990:stk500boot.c  **** 	{
 991:stk500boot.c  **** 		_delay_ms(0.5);
 992:stk500boot.c  **** 	}
 993:stk500boot.c  **** }
 994:stk500boot.c  **** 
 995:stk500boot.c  **** 
 996:stk500boot.c  **** 
 997:stk500boot.c  **** //*****************************************************************************
 998:stk500boot.c  **** /*
 999:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
1000:stk500boot.c  ****  */
1001:stk500boot.c  **** static void sendchar(char c)
1002:stk500boot.c  **** {
 1110               		.loc 1 1002 0
 1111               		.cfi_startproc
 1112               	.LVL103:
 1113               	/* prologue: function */
 1114               	/* frame size = 0 */
 1115               	/* stack size = 0 */
 1116               	.L__stack_usage = 0
1003:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 1117               		.loc 1 1003 0
 1118 04c8 8093 C600 		sts 198,r24
 1119               	.LVL104:
 1120               	.L41:
1004:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
 1121               		.loc 1 1004 0 discriminator 1
 1122 04cc 8091 C000 		lds r24,192
 1123 04d0 86FF      		sbrs r24,6
 1124 04d2 00C0      		rjmp .L41
1005:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
 1125               		.loc 1 1005 0
 1126 04d4 8091 C000 		lds r24,192
 1127 04d8 8064      		ori r24,lo8(64)
 1128 04da 8093 C000 		sts 192,r24
 1129               	.LVL105:
 1130               	/* epilogue start */
1006:stk500boot.c  **** }
 1131               		.loc 1 1006 0
 1132 04de 0895      		ret
 1133               		.cfi_endproc
 1134               	.LFE31:
 1136               	.global	PrintDecInt
 1138               	PrintDecInt:
 1139               	.LFB11:
 438:stk500boot.c  **** int	theChar;
 1140               		.loc 1 438 0
 1141               		.cfi_startproc
 1142               	.LVL106:
 1143 04e0 0F93      		push r16
 1144               	.LCFI45:
 1145               		.cfi_def_cfa_offset 4
 1146               		.cfi_offset 16, -3
 1147 04e2 1F93      		push r17
 1148               	.LCFI46:
 1149               		.cfi_def_cfa_offset 5
 1150               		.cfi_offset 17, -4
 1151 04e4 CF93      		push r28
 1152               	.LCFI47:
 1153               		.cfi_def_cfa_offset 6
 1154               		.cfi_offset 28, -5
 1155 04e6 DF93      		push r29
 1156               	.LCFI48:
 1157               		.cfi_def_cfa_offset 7
 1158               		.cfi_offset 29, -6
 1159               	/* prologue: function */
 1160               	/* frame size = 0 */
 1161               	/* stack size = 4 */
 1162               	.L__stack_usage = 4
 1163 04e8 EC01      		movw r28,r24
 1164 04ea 8B01      		movw r16,r22
 1165               	.LVL107:
 444:stk500boot.c  **** 	{
 1166               		.loc 1 444 0
 1167 04ec 8536      		cpi r24,101
 1168 04ee 9105      		cpc r25,__zero_reg__
 1169 04f0 04F4      		brge .L45
 444:stk500boot.c  **** 	{
 1170               		.loc 1 444 0 is_stmt 0 discriminator 1
 1171 04f2 6330      		cpi r22,3
 1172 04f4 7105      		cpc r23,__zero_reg__
 1173 04f6 04F0      		brlt .L46
 1174               	.L45:
 1175               	.LVL108:
 446:stk500boot.c  **** 		sendchar(theChar );
 1176               		.loc 1 446 0 is_stmt 1
 1177 04f8 CE01      		movw r24,r28
 1178               	.LVL109:
 1179 04fa 64E6      		ldi r22,lo8(100)
 1180 04fc 70E0      		ldi r23,0
 1181               	.LVL110:
 1182 04fe 0E94 0000 		call __divmodhi4
 1183               	.LVL111:
 447:stk500boot.c  **** 	}
 1184               		.loc 1 447 0
 1185 0502 80E3      		ldi r24,lo8(48)
 1186 0504 860F      		add r24,r22
 1187 0506 0E94 0000 		call sendchar
 1188               	.LVL112:
 1189               	.L46:
 450:stk500boot.c  **** 	{
 1190               		.loc 1 450 0
 1191 050a CB30      		cpi r28,11
 1192 050c D105      		cpc r29,__zero_reg__
 1193 050e 04F4      		brge .L47
 450:stk500boot.c  **** 	{
 1194               		.loc 1 450 0 is_stmt 0 discriminator 1
 1195 0510 0230      		cpi r16,2
 1196 0512 1105      		cpc r17,__zero_reg__
 1197 0514 04F0      		brlt .L48
 1198               	.L47:
 1199               	.LVL113:
 452:stk500boot.c  **** 		sendchar(theChar );
 1200               		.loc 1 452 0 is_stmt 1
 1201 0516 CE01      		movw r24,r28
 1202 0518 64E6      		ldi r22,lo8(100)
 1203 051a 70E0      		ldi r23,0
 1204 051c 0E94 0000 		call __divmodhi4
 1205 0520 6AE0      		ldi r22,lo8(10)
 1206 0522 70E0      		ldi r23,0
 1207 0524 0E94 0000 		call __divmodhi4
 453:stk500boot.c  **** 	}
 1208               		.loc 1 453 0
 1209 0528 80E3      		ldi r24,lo8(48)
 1210 052a 860F      		add r24,r22
 1211 052c 0E94 0000 		call sendchar
 1212               	.LVL114:
 1213               	.L48:
 455:stk500boot.c  **** 	sendchar(theChar );
 1214               		.loc 1 455 0
 1215 0530 CE01      		movw r24,r28
 1216 0532 6AE0      		ldi r22,lo8(10)
 1217 0534 70E0      		ldi r23,0
 1218 0536 0E94 0000 		call __divmodhi4
 456:stk500boot.c  **** }
 1219               		.loc 1 456 0
 1220 053a 805D      		subi r24,lo8(-(48))
 1221               	/* epilogue start */
 457:stk500boot.c  **** static unsigned char recchar(void);
 1222               		.loc 1 457 0
 1223 053c DF91      		pop r29
 1224 053e CF91      		pop r28
 1225               	.LVL115:
 1226 0540 1F91      		pop r17
 1227 0542 0F91      		pop r16
 1228               	.LVL116:
 456:stk500boot.c  **** }
 1229               		.loc 1 456 0
 1230 0544 0C94 0000 		jmp sendchar
 1231               	.LVL117:
 1232               		.cfi_endproc
 1233               	.LFE11:
 1235               		.section	.init9,"ax",@progbits
 1236               	.global	__jumpMain
 1238               	__jumpMain:
 1239               	.LFB29:
 965:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 1240               		.loc 1 965 0
 1241               		.cfi_startproc
 1242               	/* prologue: naked */
 1243               	/* frame size = 0 */
 1244               	/* stack size = 0 */
 1245               	.L__stack_usage = 0
 969:stk500boot.c  **** 
 1246               		.loc 1 969 0
 1247               	/* #APP */
 1248               	 ;  969 "stk500boot.c" 1
 1249               		.set __stack, 8703
 1250               	 ;  0 "" 2
 973:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 1251               		.loc 1 973 0
 1252               	 ;  973 "stk500boot.c" 1
 1253 0000 01E2      		ldi	16, 33
 1254               	 ;  0 "" 2
 974:stk500boot.c  **** 
 1255               		.loc 1 974 0
 1256               	 ;  974 "stk500boot.c" 1
 1257 0002 0EBF      		out 62,16
 1258               	 ;  0 "" 2
 976:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 1259               		.loc 1 976 0
 1260               	 ;  976 "stk500boot.c" 1
 1261 0004 0FEF      		ldi	16, 255
 1262               	 ;  0 "" 2
 977:stk500boot.c  **** 
 1263               		.loc 1 977 0
 1264               	 ;  977 "stk500boot.c" 1
 1265 0006 0DBF      		out 61,16
 1266               	 ;  0 "" 2
 979:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 1267               		.loc 1 979 0
 1268               	 ;  979 "stk500boot.c" 1
 1269 0008 1124      		clr __zero_reg__
 1270               	 ;  0 "" 2
 980:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 1271               		.loc 1 980 0
 1272               	 ;  980 "stk500boot.c" 1
 1273 000a 1FBE      		out 63, __zero_reg__
 1274               	 ;  0 "" 2
 981:stk500boot.c  **** }
 1275               		.loc 1 981 0
 1276               	 ;  981 "stk500boot.c" 1
 1277 000c 0C94 0000 		jmp main
 1278               	 ;  0 "" 2
 1279               	/* epilogue start */
 982:stk500boot.c  **** 
 1280               		.loc 1 982 0
 1281               	/* #NOAPP */
 1282               		.cfi_endproc
 1283               	.LFE29:
 1285               		.text
 1286               	.global	delay_ms
 1288               	delay_ms:
 1289               	.LFB30:
 987:stk500boot.c  **** 	unsigned int i;
 1290               		.loc 1 987 0
 1291               		.cfi_startproc
 1292               	.LVL118:
 1293               	/* prologue: function */
 1294               	/* frame size = 0 */
 1295               	/* stack size = 0 */
 1296               	.L__stack_usage = 0
 989:stk500boot.c  **** 	{
 1297               		.loc 1 989 0
 1298 0548 30E0      		ldi r19,0
 1299 054a 20E0      		ldi r18,0
 1300               	.LVL119:
 1301               	.L51:
 989:stk500boot.c  **** 	{
 1302               		.loc 1 989 0 is_stmt 0 discriminator 1
 1303 054c 2817      		cp r18,r24
 1304 054e 3907      		cpc r19,r25
 1305 0550 01F4      		brne .L52
 1306               	/* epilogue start */
 993:stk500boot.c  **** 
 1307               		.loc 1 993 0 is_stmt 1
 1308 0552 0895      		ret
 1309               	.L52:
 1310               	.LVL120:
 1311               	.LBB74:
 1312               	.LBB75:
 1313               		.file 2 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1314               		.loc 2 187 0
 1315 0554 EFEC      		ldi r30,lo8(1999)
 1316 0556 F7E0      		ldi r31,hi8(1999)
 1317 0558 3197      	1:	sbiw r30,1
 1318 055a 01F4      		brne 1b
 1319 055c 00C0      		rjmp .
 1320 055e 0000      		nop
 1321               	.LVL121:
 1322               	.LBE75:
 1323               	.LBE74:
 989:stk500boot.c  **** 	{
 1324               		.loc 1 989 0
 1325 0560 2F5F      		subi r18,-1
 1326 0562 3F4F      		sbci r19,-1
 1327               	.LVL122:
 1328 0564 00C0      		rjmp .L51
 1329               		.cfi_endproc
 1330               	.LFE30:
 1332               	.global	getData
 1334               	getData:
 1335               	.LFB35:
1007:stk500boot.c  **** 
1008:stk500boot.c  **** 
1009:stk500boot.c  **** //************************************************************************
1010:stk500boot.c  **** static int	Serial_Available(void)
1011:stk500boot.c  **** {
1012:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
1013:stk500boot.c  **** }
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 
1016:stk500boot.c  **** //*****************************************************************************
1017:stk500boot.c  **** /*
1018:stk500boot.c  ****  * Read single byte from USART, block if no data available
1019:stk500boot.c  ****  */
1020:stk500boot.c  **** static unsigned char recchar(void)
1021:stk500boot.c  **** {
1022:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
1023:stk500boot.c  **** 	{
1024:stk500boot.c  **** 		// wait for data
1025:stk500boot.c  **** 	}
1026:stk500boot.c  **** 	return UART_DATA_REG;
1027:stk500boot.c  **** }
1028:stk500boot.c  **** 
1029:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
1030:stk500boot.c  **** //*****************************************************************************
1031:stk500boot.c  **** static unsigned char recchar_timeout(void)
1032:stk500boot.c  **** {
1033:stk500boot.c  **** uint32_t count = 0;
1034:stk500boot.c  **** 
1035:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
1036:stk500boot.c  **** 	{
1037:stk500boot.c  **** 		// wait for data
1038:stk500boot.c  **** 		count++;
1039:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
1040:stk500boot.c  **** 		{
1041:stk500boot.c  **** 		unsigned int	data;
1042:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
1043:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
1044:stk500boot.c  **** 		#else
1045:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
1046:stk500boot.c  **** 		#endif
1047:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
1048:stk500boot.c  **** 			{
1049:stk500boot.c  **** 				asm volatile(
1050:stk500boot.c  **** 						"clr	r30		\n\t"
1051:stk500boot.c  **** 						"clr	r31		\n\t"
1052:stk500boot.c  **** 						"ijmp	\n\t"
1053:stk500boot.c  **** 						);
1054:stk500boot.c  **** 			}
1055:stk500boot.c  **** 			count	=	0;
1056:stk500boot.c  **** 		}
1057:stk500boot.c  **** 	}
1058:stk500boot.c  **** 	return UART_DATA_REG;
1059:stk500boot.c  **** }
1060:stk500boot.c  **** unsigned char getData(unsigned int* boot_state)
1061:stk500boot.c  **** {
 1336               		.loc 1 1061 0
 1337               		.cfi_startproc
 1338               	.LVL123:
 1339               	/* prologue: function */
 1340               	/* frame size = 0 */
 1341               	/* stack size = 0 */
 1342               	.L__stack_usage = 0
1062:stk500boot.c  ****   unsigned char c;
1063:stk500boot.c  ****   if (*boot_state==1)
 1343               		.loc 1 1063 0
 1344 0566 FC01      		movw r30,r24
 1345 0568 2081      		ld r18,Z
 1346 056a 3181      		ldd r19,Z+1
 1347 056c 2130      		cpi r18,1
 1348 056e 3105      		cpc r19,__zero_reg__
 1349 0570 01F4      		brne .L57
1064:stk500boot.c  ****   {
1065:stk500boot.c  ****     *boot_state	=	0;
 1350               		.loc 1 1065 0
 1351 0572 1182      		std Z+1,__zero_reg__
 1352 0574 1082      		st Z,__zero_reg__
 1353               	.LVL124:
 1354               	.L63:
 1355               	.LBB80:
 1356               	.LBB81:
1058:stk500boot.c  **** }
 1357               		.loc 1 1058 0
 1358 0576 8091 C600 		lds r24,198
 1359               	.LVL125:
 1360               	/* epilogue start */
 1361               	.LBE81:
 1362               	.LBE80:
1066:stk500boot.c  ****     c			=	UART_DATA_REG;
1067:stk500boot.c  ****   }
1068:stk500boot.c  ****   else
1069:stk500boot.c  ****   {
1070:stk500boot.c  ****   //	c	=	recchar();
1071:stk500boot.c  ****     c	=	recchar_timeout();
1072:stk500boot.c  **** 
1073:stk500boot.c  ****   }
1074:stk500boot.c  ****   return c;
1075:stk500boot.c  **** }
 1363               		.loc 1 1075 0
 1364 057a 0895      		ret
 1365               	.LVL126:
 1366               	.L58:
 1367 057c 0197      		sbiw r24,1
 1368 057e A109      		sbc r26,__zero_reg__
 1369 0580 B109      		sbc r27,__zero_reg__
 1370               	.LVL127:
 1371               	.LBB86:
 1372               	.LBB84:
1039:stk500boot.c  **** 		{
 1373               		.loc 1 1039 0
 1374 0582 01F4      		brne .L56
 1375               	.LVL128:
 1376               	.LBB82:
 1377               	.LBB83:
1043:stk500boot.c  **** 		#else
 1378               		.loc 1 1043 0
 1379               	/* #APP */
 1380               	 ;  1043 "stk500boot.c" 1
 1381 0584 ABBF      		out 59, r26
 1382 0586 FC01      		movw r30, r24
 1383 0588 8791      		elpm r24, Z+
 1384 058a 9691      		elpm r25, Z
 1385               		
 1386               	 ;  0 "" 2
 1387               	.LVL129:
 1388               	/* #NOAPP */
 1389               	.LBE83:
1047:stk500boot.c  **** 			{
 1390               		.loc 1 1047 0
 1391 058c 0196      		adiw r24,1
 1392 058e 01F0      		breq .L57
1049:stk500boot.c  **** 						"clr	r30		\n\t"
 1393               		.loc 1 1049 0
 1394               	/* #APP */
 1395               	 ;  1049 "stk500boot.c" 1
 1396 0590 EE27      		clr	r30		
 1397 0592 FF27      		clr	r31		
 1398 0594 0994      		ijmp	
 1399               		
 1400               	 ;  0 "" 2
 1401               	.LVL130:
 1402               	/* #NOAPP */
 1403               	.L57:
 1404               	.LBE82:
 1405               	.LBE84:
 1406               	.LBE86:
1061:stk500boot.c  ****   unsigned char c;
 1407               		.loc 1 1061 0
 1408 0596 81E0      		ldi r24,lo8(1)
 1409 0598 92E1      		ldi r25,lo8(18)
 1410 059a AAE7      		ldi r26,lo8(122)
 1411 059c B0E0      		ldi r27,0
 1412               	.L56:
 1413               	.LVL131:
 1414               	.LBB87:
 1415               	.LBB85:
1035:stk500boot.c  **** 	{
 1416               		.loc 1 1035 0
 1417 059e 2091 C000 		lds r18,192
 1418 05a2 27FF      		sbrs r18,7
 1419 05a4 00C0      		rjmp .L58
 1420 05a6 00C0      		rjmp .L63
 1421               	.LBE85:
 1422               	.LBE87:
 1423               		.cfi_endproc
 1424               	.LFE35:
 1426               		.section	.text.startup,"ax",@progbits
 1427               	.global	main
 1429               	main:
 1430               	.LFB36:
1076:stk500boot.c  **** 
1077:stk500boot.c  **** 
1078:stk500boot.c  **** //*	for watch dog timer startup
1079:stk500boot.c  **** void (*app_start)(void) = 0x0000;
1080:stk500boot.c  **** // static unsigned char in[]  = {
1081:stk500boot.c  **** // 	0x7B,0x17,0x19,0x77,0xB7,0xA4,0x8D,0x72,0x24,0x58,0x12,0x6B,0x10,0x02,0x13,0x5F,
1082:stk500boot.c  **** // 	0x91,0x76,0xC6,0x46,0xB4,0x30,0xEA,0xD1,0x47,0xBE,0x8D,0xC8,0x8B,0x28,0xCD,0x04,
1083:stk500boot.c  **** // 	0x09,0x20,0xEE,0x44,0x41,0xFD,0xBC,0xED,0x8F,0x37,0x0F,0x99,0x55,0x05,0x99,0xCE,
1084:stk500boot.c  **** // 	0x19,0xBD,0x0A,0xDC,0xC6,0x0C,0xD4,0x69,0x3C,0x1E,0x93,0x55,0xD0,0x70,0x8C,0x44,
1085:stk500boot.c  **** // 	0xCB,0x8E,0xFB,0x7E,0x92,0x28,0xB2,0xB5,0xEB,0xE8,0xE8,0xC6,0xA1,0xDE,0x96,0x41,
1086:stk500boot.c  **** // 	0x0E,0x35,0x38,0xF7,0x2F,0x16,0xFD,0x6A,0xD0,0xEE,0xBE,0x8D,0x24,0x0D,0x20,0xB7,
1087:stk500boot.c  **** // 	0x0E,0x6C,0xC2,0x66,0xCC,0xDE,0x04,0xE5,0xA5,0xCD,0x9F,0x85,0xE6,0x59,0xB3,0x78,
1088:stk500boot.c  **** // 	0xA9,0x1E,0xB5,0x25,0xE8,0x27,0x9E,0x1B,0x28,0x86,0x41,0x48,0x2F,0x5A,0x8D,0x20,
1089:stk500boot.c  **** // 	0x2A,0x74,0x1B,0xE8,0x6E,0x02,0xE4,0xD0,0x71,0x48,0xD2,0x41,0x0F,0x61,0x83,0xEC,
1090:stk500boot.c  **** // 	0x8E,0x44,0xA8,0x6D,0xEC,0xD3,0xC2,0x08,0xC7,0x51,0xBD,0xD3,0x1D,0x12,0x8A,0xB8,
1091:stk500boot.c  **** // 	0x15,0x7F,0x79,0x00,0xD2,0xC5,0xB0,0xB2,0x50,0xA9,0x45,0x96,0x6D,0xEA,0x4F,0xAD,
1092:stk500boot.c  **** // 	0x0B,0xFC,0xB7,0xAE,0xB7,0x1A,0xFB,0x94,0x1B,0x25,0x52,0x80,0x28,0x09,0x5B,0x4E,
1093:stk500boot.c  **** // 	0x64,0xD2,0x8A,0xE1,0x2F,0x7A,0x4C,0xFA,0x74,0x4E,0x27,0xB1,0x14,0x70,0x29,0x20,
1094:stk500boot.c  **** // 	0x22,0xC6,0x1C,0x39,0xAC,0xD1,0x51,0x95,0x95,0x16,0x98,0xE1,0xB2,0xE2,0x19,0x57,
1095:stk500boot.c  **** // 	0xB4,0x91,0x09,0xDD,0xA6,0x53,0x07,0x73,0x47,0x3C,0x0E,0x5E,0x13,0x69,0xE9,0x99,
1096:stk500boot.c  **** // 	0x4F,0x4E,0x61,0x4A,0xA3,0xF7,0x27,0x2F,0xD4,0x8B,0x00,0x27,0xAF,0x22,0x44,0xD4};
1097:stk500boot.c  **** 
1098:stk500boot.c  ****  unsigned char	receivedPacket[288] ={
1099:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1100:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1101:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1102:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1103:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1104:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1105:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1106:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1107:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1108:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1109:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1110:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1111:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1112:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1113:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1114:stk500boot.c  ****   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1115:stk500boot.c  ****   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
1116:stk500boot.c  **** 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
1117:stk500boot.c  **** 
1118:stk500boot.c  **** };
1119:stk500boot.c  **** 
1120:stk500boot.c  ****  unsigned char aes_buffer[288] = {
1121:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1122:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1123:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1124:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1125:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1126:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1127:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1128:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1129:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1130:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1131:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1132:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1133:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1134:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1135:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1136:stk500boot.c  ****   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1137:stk500boot.c  ****   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
1138:stk500boot.c  **** 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
1139:stk500boot.c  **** //*****************************************************************************
1140:stk500boot.c  **** 
1141:stk500boot.c  **** 	unsigned char authenticationToken[4] = {0x53, 0xef, 0x34,0x23};
1142:stk500boot.c  **** 
1143:stk500boot.c  **** union{
1144:stk500boot.c  **** 	uint32_t  authenticationNumber;
1145:stk500boot.c  **** 	uint8_t authBytes[4]
1146:stk500boot.c  **** }authenticationNumber;
1147:stk500boot.c  **** 
1148:stk500boot.c  **** #define AUTHENTICATION
1149:stk500boot.c  **** 
1150:stk500boot.c  **** int main(void)
1151:stk500boot.c  **** {
 1431               		.loc 1 1151 0
 1432               		.cfi_startproc
 1433 0000 CF93      		push r28
 1434               	.LCFI49:
 1435               		.cfi_def_cfa_offset 4
 1436               		.cfi_offset 28, -3
 1437 0002 DF93      		push r29
 1438               	.LCFI50:
 1439               		.cfi_def_cfa_offset 5
 1440               		.cfi_offset 29, -4
 1441 0004 CDB7      		in r28,__SP_L__
 1442 0006 DEB7      		in r29,__SP_H__
 1443               	.LCFI51:
 1444               		.cfi_def_cfa_register 28
 1445 0008 C752      		subi r28,39
 1446 000a D140      		sbci r29,1
 1447               	.LCFI52:
 1448               		.cfi_def_cfa_offset 300
 1449 000c 0FB6      		in __tmp_reg__,__SREG__
 1450 000e F894      		cli
 1451 0010 DEBF      		out __SP_H__,r29
 1452 0012 0FBE      		out __SREG__,__tmp_reg__
 1453 0014 CDBF      		out __SP_L__,r28
 1454               	/* prologue: function */
 1455               	/* frame size = 295 */
 1456               	/* stack size = 297 */
 1457               	.L__stack_usage = 297
 1458               	.LVL132:
1152:stk500boot.c  ****   unsigned char  packetSize = 0;
1153:stk500boot.c  **** 	unsigned int residualNumber = 0;
1154:stk500boot.c  ****   unsigned char packetRetrieveState;
1155:stk500boot.c  ****   packetRetrieveState = SOTA_PACKET_RETRIEVE_START;
1156:stk500boot.c  ****   int packetRetrieveIndex = 0;
1157:stk500boot.c  **** 	address_t		address			=	0;
1158:stk500boot.c  **** 	address_t		eraseAddress	=	0;
1159:stk500boot.c  **** 	unsigned char	msgParseState;
1160:stk500boot.c  **** 	unsigned int	ii				=	0;
1161:stk500boot.c  **** 	unsigned char	checksum		=	0;
1162:stk500boot.c  **** 	unsigned char	seqNum			=	0;
1163:stk500boot.c  **** 	unsigned int	msgLength		=	0;
1164:stk500boot.c  **** 	unsigned char	msgBuffer[285];
1165:stk500boot.c  **** 
1166:stk500boot.c  **** 	unsigned char isAuthenticated = 0x00;
1167:stk500boot.c  **** 	unsigned int finalResponseSize;
1168:stk500boot.c  **** 
1169:stk500boot.c  **** 	unsigned int receivedPacketIndex = 0;
1170:stk500boot.c  **** 
1171:stk500boot.c  **** 	//unsigned char msgBuffer[290];
1172:stk500boot.c  **** 	unsigned long int 	sequenceNumber = 0;
1173:stk500boot.c  **** 	unsigned char	c, *p;
1174:stk500boot.c  **** 	unsigned char   isLeave = 0;
1175:stk500boot.c  **** 	unsigned long	boot_timeout;
1176:stk500boot.c  **** 	unsigned long	boot_timer;
1177:stk500boot.c  **** 	unsigned int	boot_state;
1178:stk500boot.c  **** #ifdef ENABLE_MONITOR
1179:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
1180:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
1181:stk500boot.c  **** #endif
1182:stk500boot.c  **** 
1183:stk500boot.c  **** 	//*	some chips dont set the stack properly
1184:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 1459               		.loc 1 1184 0
 1460               	/* #APP */
 1461               	 ;  1184 "stk500boot.c" 1
 1462               		.set __stack, 8703
 1463               	 ;  0 "" 2
1185:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 1464               		.loc 1 1185 0
 1465               	 ;  1185 "stk500boot.c" 1
 1466 0016 01E2      		ldi	16, 33
 1467               	 ;  0 "" 2
1186:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 1468               		.loc 1 1186 0
 1469               	 ;  1186 "stk500boot.c" 1
 1470 0018 0EBF      		out 62,16
 1471               	 ;  0 "" 2
1187:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 1472               		.loc 1 1187 0
 1473               	 ;  1187 "stk500boot.c" 1
 1474 001a 0FEF      		ldi	16, 255
 1475               	 ;  0 "" 2
1188:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 1476               		.loc 1 1188 0
 1477               	 ;  1188 "stk500boot.c" 1
 1478 001c 0DBF      		out 61,16
 1479               	 ;  0 "" 2
1189:stk500boot.c  **** 
1190:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
1191:stk500boot.c  **** 	//************************************************************************
1192:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
1193:stk500boot.c  **** 	//*	handle the watch dog timer
1194:stk500boot.c  **** 	uint8_t	mcuStatusReg;
1195:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 1480               		.loc 1 1195 0
 1481               	/* #NOAPP */
 1482 001e 94B7      		in r25,0x34
 1483               	.LVL133:
1196:stk500boot.c  **** 
1197:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 1484               		.loc 1 1197 0
 1485               	/* #APP */
 1486               	 ;  1197 "stk500boot.c" 1
 1487 0020 F894      		cli
 1488               	 ;  0 "" 2
1198:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 1489               		.loc 1 1198 0
 1490               	 ;  1198 "stk500boot.c" 1
 1491 0022 A895      		wdr
 1492               	 ;  0 "" 2
1199:stk500boot.c  **** 	MCUSR	=	0;
 1493               		.loc 1 1199 0
 1494               	/* #NOAPP */
 1495 0024 14BE      		out 0x34,__zero_reg__
1200:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 1496               		.loc 1 1200 0
 1497 0026 8091 6000 		lds r24,96
 1498 002a 8861      		ori r24,lo8(24)
 1499 002c 8093 6000 		sts 96,r24
1201:stk500boot.c  **** 	WDTCSR	=	0;
 1500               		.loc 1 1201 0
 1501 0030 1092 6000 		sts 96,__zero_reg__
1202:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 1502               		.loc 1 1202 0
 1503               	/* #APP */
 1504               	 ;  1202 "stk500boot.c" 1
 1505 0034 7894      		sei
 1506               	 ;  0 "" 2
1203:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
1204:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 1507               		.loc 1 1204 0
 1508               	/* #NOAPP */
 1509 0036 93FF      		sbrs r25,3
 1510 0038 00C0      		rjmp .L65
1205:stk500boot.c  **** 	{
1206:stk500boot.c  **** 		app_start();
 1511               		.loc 1 1206 0
 1512 003a E091 0000 		lds r30,app_start
 1513 003e F091 0000 		lds r31,app_start+1
 1514 0042 1995      		eicall
 1515               	.LVL134:
 1516               	.L65:
1207:stk500boot.c  **** 	}
1208:stk500boot.c  **** 	//************************************************************************
1209:stk500boot.c  **** #endif
1210:stk500boot.c  **** 
1211:stk500boot.c  **** // #ifdef BLINK_LED_WHILE_WAITING
1212:stk500boot.c  **** // //	boot_timeout	=	 90000;		//*	should be about 4 seconds
1213:stk500boot.c  **** // //	boot_timeout	=	170000;
1214:stk500boot.c  **** // 	boot_timeout	=	 20000;		//*	should be about 1 second
1215:stk500boot.c  **** // #else
1216:stk500boot.c  **** // 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
1217:stk500boot.c  **** // #endif
1218:stk500boot.c  **** 
1219:stk500boot.c  **** 	boot_timer	=	0;
1220:stk500boot.c  **** 	boot_state	=	0;
 1517               		.loc 1 1220 0
 1518 0044 C25E      		subi r28,lo8(-286)
 1519 0046 DE4F      		sbci r29,hi8(-286)
 1520 0048 1982      		std Y+1,__zero_reg__
 1521 004a 1882      		st Y,__zero_reg__
 1522 004c CE51      		subi r28,lo8(286)
 1523 004e D140      		sbci r29,hi8(286)
 1524               	.LVL135:
1221:stk500boot.c  **** 	boot_timeout = 3500000;
1222:stk500boot.c  **** 	/*
1223:stk500boot.c  **** 	 * Init UART
1224:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
1225:stk500boot.c  **** 	 */
1226:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
1227:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 1525               		.loc 1 1227 0
 1526 0050 8091 C000 		lds r24,192
 1527 0054 8260      		ori r24,lo8(2)
 1528 0056 8093 C000 		sts 192,r24
1228:stk500boot.c  **** #endif
1229:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 1529               		.loc 1 1229 0
 1530 005a 80E1      		ldi r24,lo8(16)
 1531 005c 8093 C400 		sts 196,r24
1230:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 1532               		.loc 1 1230 0
 1533 0060 88E1      		ldi r24,lo8(24)
 1534 0062 8093 C100 		sts 193,r24
1231:stk500boot.c  **** 
1232:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 1535               		.loc 1 1232 0
 1536               	/* #APP */
 1537               	 ;  1232 "stk500boot.c" 1
 1538 0066 0000      		nop
 1539               	 ;  0 "" 2
1219:stk500boot.c  **** 	boot_state	=	0;
 1540               		.loc 1 1219 0
 1541               	/* #NOAPP */
 1542 0068 40E0      		ldi r20,0
 1543 006a 50E0      		ldi r21,0
 1544 006c BA01      		movw r22,r20
1233:stk500boot.c  **** 
1234:stk500boot.c  **** 
1235:stk500boot.c  **** 	while (boot_state==0)
1236:stk500boot.c  **** 	{
1237:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
1238:stk500boot.c  **** 		{
1239:stk500boot.c  **** 			_delay_ms(0.001);
1240:stk500boot.c  **** 			boot_timer++;
1241:stk500boot.c  **** 			if (boot_timer > boot_timeout)
1242:stk500boot.c  **** 			{
1243:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 1545               		.loc 1 1243 0
 1546 006e 21E0      		ldi r18,lo8(1)
 1547 0070 30E0      		ldi r19,0
 1548               	.LVL136:
 1549               	.L66:
1235:stk500boot.c  **** 	{
 1550               		.loc 1 1235 0
 1551 0072 C25E      		subi r28,lo8(-286)
 1552 0074 DE4F      		sbci r29,hi8(-286)
 1553 0076 8881      		ld r24,Y
 1554 0078 9981      		ldd r25,Y+1
 1555 007a CE51      		subi r28,lo8(286)
 1556 007c D140      		sbci r29,hi8(286)
 1557 007e 0097      		sbiw r24,0
 1558 0080 01F0      		breq .L70
1244:stk500boot.c  **** 			}
1245:stk500boot.c  **** 		}
1246:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
1247:stk500boot.c  **** 	}
1248:stk500boot.c  **** 
1249:stk500boot.c  **** 		// PrintDecInt(boot_state,10);
1250:stk500boot.c  **** 
1251:stk500boot.c  **** // sendchar(0x32);
1252:stk500boot.c  **** 
1253:stk500boot.c  **** 
1254:stk500boot.c  **** 
1255:stk500boot.c  **** 
1256:stk500boot.c  **** 	if (boot_state==1)
 1559               		.loc 1 1256 0
 1560 0082 0197      		sbiw r24,1
 1561 0084 01F0      		breq .+2
 1562 0086 00C0      		rjmp .L72
1166:stk500boot.c  **** 	unsigned int finalResponseSize;
 1563               		.loc 1 1166 0
 1564 0088 CC5D      		subi r28,lo8(-292)
 1565 008a DE4F      		sbci r29,hi8(-292)
 1566 008c 1882      		st Y,__zero_reg__
 1567 008e C452      		subi r28,lo8(292)
 1568 0090 D140      		sbci r29,hi8(292)
1162:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 1569               		.loc 1 1162 0
 1570 0092 CB5D      		subi r28,lo8(-293)
 1571 0094 DE4F      		sbci r29,hi8(-293)
 1572 0096 1882      		st Y,__zero_reg__
 1573 0098 C552      		subi r28,lo8(293)
 1574 009a D140      		sbci r29,hi8(293)
1161:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 1575               		.loc 1 1161 0
 1576 009c B12C      		mov r11,__zero_reg__
1160:stk500boot.c  **** 	unsigned char	checksum		=	0;
 1577               		.loc 1 1160 0
 1578 009e 912C      		mov r9,__zero_reg__
 1579 00a0 812C      		mov r8,__zero_reg__
1158:stk500boot.c  **** 	unsigned char	msgParseState;
 1580               		.loc 1 1158 0
 1581 00a2 C05E      		subi r28,lo8(-288)
 1582 00a4 DE4F      		sbci r29,hi8(-288)
 1583 00a6 1882      		st Y,__zero_reg__
 1584 00a8 1982      		std Y+1,__zero_reg__
 1585 00aa 1A82      		std Y+2,__zero_reg__
 1586 00ac 1B82      		std Y+3,__zero_reg__
 1587 00ae C052      		subi r28,lo8(288)
 1588 00b0 D140      		sbci r29,hi8(288)
1157:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 1589               		.loc 1 1157 0
 1590 00b2 412C      		mov r4,__zero_reg__
 1591 00b4 512C      		mov r5,__zero_reg__
 1592 00b6 3201      		movw r6,r4
1152:stk500boot.c  **** 	unsigned int residualNumber = 0;
 1593               		.loc 1 1152 0
 1594 00b8 CA5D      		subi r28,lo8(-294)
 1595 00ba DE4F      		sbci r29,hi8(-294)
 1596 00bc 1882      		st Y,__zero_reg__
 1597 00be C652      		subi r28,lo8(294)
 1598 00c0 D140      		sbci r29,hi8(294)
1257:stk500boot.c  **** 	{
1258:stk500boot.c  **** 		while (!isLeave)
1259:stk500boot.c  **** 		{
1260:stk500boot.c  **** 
1261:stk500boot.c  **** 			packetRetrieveIndex = 0;
1262:stk500boot.c  **** 		  packetRetrieveState = SOTA_PACKET_RETRIEVE_START;
1263:stk500boot.c  **** 		   while ( packetRetrieveState != SOTA_PACKET_RETRIEVE_FINISHED )
1264:stk500boot.c  **** 		   {
1265:stk500boot.c  **** 
1266:stk500boot.c  **** 		     c = getData(&boot_state);
1267:stk500boot.c  **** 		     if (packetRetrieveState == SOTA_PACKET_RETRIEVE_START)
1268:stk500boot.c  **** 		  	{
1269:stk500boot.c  **** 		     if(c == SOTA_MESSAGE_START)
1270:stk500boot.c  **** 		     {
1271:stk500boot.c  **** 		       packetRetrieveState = SOTA_PACKET_RETRIEVE_SIZE;
1272:stk500boot.c  **** 		       }
1273:stk500boot.c  **** 		     }
1274:stk500boot.c  **** 		     else if(packetRetrieveState == SOTA_PACKET_RETRIEVE_SIZE)
1275:stk500boot.c  **** 		     {
1276:stk500boot.c  **** 		       unsigned char lowest = getData(&boot_state);
1277:stk500boot.c  **** 
1278:stk500boot.c  **** 		       packetSize 	=	((c)<<8) | lowest; // ok
1279:stk500boot.c  **** 		       packetRetrieveState = SOTA_PACKET_RETRIEVE_PROCESSING;
1280:stk500boot.c  **** 
1281:stk500boot.c  **** 		     }
1282:stk500boot.c  **** 		     else if(packetRetrieveState == SOTA_PACKET_RETRIEVE_PROCESSING)
1283:stk500boot.c  **** 		     {
1284:stk500boot.c  **** 		       if(packetRetrieveIndex < packetSize){
1285:stk500boot.c  **** 		       receivedPacket[packetRetrieveIndex] = c;
1286:stk500boot.c  **** 		  		//sendchar(c);
1287:stk500boot.c  **** 		  		packetRetrieveIndex++;
1288:stk500boot.c  **** 		  	}
1289:stk500boot.c  **** 		       else{
1290:stk500boot.c  **** 		       packetRetrieveState = SOTA_PACKET_RETRIEVE_FINISHED;}
1291:stk500boot.c  **** 		     }
1292:stk500boot.c  **** 		   }
1293:stk500boot.c  **** 			//   sendchar(0x98);
1294:stk500boot.c  **** 			//  for(int i=0; i<packetSize;i++)
1295:stk500boot.c  **** 			//  sendchar(receivedPacket[i]);
1296:stk500boot.c  **** 			//  sendchar(0x33);
1297:stk500boot.c  **** 			// sendchar(0x59);
1298:stk500boot.c  **** 			// PrintDecInt(packetSize,10);
1299:stk500boot.c  **** 			// sendchar(0x60);
1300:stk500boot.c  **** 
1301:stk500boot.c  **** 		   aes_decrypt(aes_buffer, receivedPacket, packetSize);
1302:stk500boot.c  ****   // sendchar(0x34);
1303:stk500boot.c  **** 
1304:stk500boot.c  ****  // for(int i=0; i<packetSize;i++)
1305:stk500boot.c  ****  // sendchar(aes_buffer[i]);
1306:stk500boot.c  ****  // sendchar(0x99);
1307:stk500boot.c  **** 
1308:stk500boot.c  **** 
1309:stk500boot.c  **** 
1310:stk500boot.c  **** 
1311:stk500boot.c  **** 			 receivedPacketIndex = 0;
1312:stk500boot.c  **** 			msgParseState	=	ST_START;
1313:stk500boot.c  **** 			while (msgParseState != ST_PROCESS )
1314:stk500boot.c  **** 			{
1315:stk500boot.c  **** 				c = aes_buffer[receivedPacketIndex];
1316:stk500boot.c  **** 				  // sendchar(c);
1317:stk500boot.c  **** 
1318:stk500boot.c  **** 				switch (msgParseState)
1319:stk500boot.c  **** 				{
1320:stk500boot.c  **** 					case ST_START:
1321:stk500boot.c  **** 					{
1322:stk500boot.c  **** 						if ( c == MESSAGE_START )
1323:stk500boot.c  **** 						{
1324:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
1325:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
1326:stk500boot.c  **** 						}
1327:stk500boot.c  **** 						break;
1328:stk500boot.c  **** 					}
1329:stk500boot.c  **** 					case ST_GET_SEQ_NUM:{
1330:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
1331:stk500boot.c  **** 						seqNum			=	c;
1332:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
1333:stk500boot.c  **** 						checksum		^=	c;
1334:stk500boot.c  **** 					#else
1335:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
1336:stk500boot.c  **** 						{
1337:stk500boot.c  **** 							seqNum			=	c;
1338:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
1339:stk500boot.c  **** 							checksum		^=	c;
1340:stk500boot.c  **** 						}
1341:stk500boot.c  **** 						else
1342:stk500boot.c  **** 						{
1343:stk500boot.c  **** 							msgParseState	=	ST_START;
1344:stk500boot.c  **** 						}
1345:stk500boot.c  **** 					#endif
1346:stk500boot.c  **** 						break;
1347:stk500boot.c  **** 					}
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 					case ST_MSG_SIZE_1:
1350:stk500boot.c  **** 					{
1351:stk500boot.c  **** 						msgLength		=	c<<8;
1352:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
1353:stk500boot.c  **** 						checksum		^=	c;
1354:stk500boot.c  **** 						break;
1355:stk500boot.c  **** 					}
1356:stk500boot.c  **** 
1357:stk500boot.c  **** 					case ST_MSG_SIZE_2:
1358:stk500boot.c  **** 					{
1359:stk500boot.c  **** 						msgLength		|=	c;
1360:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
1361:stk500boot.c  **** 						checksum		^=	c;
1362:stk500boot.c  **** 						break;
1363:stk500boot.c  **** 					}
1364:stk500boot.c  **** 
1365:stk500boot.c  **** 					case ST_GET_TOKEN:
1366:stk500boot.c  **** 					{
1367:stk500boot.c  **** 						if ( c == TOKEN )
1368:stk500boot.c  **** 						{
1369:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
1370:stk500boot.c  **** 							checksum		^=	c;
1371:stk500boot.c  **** 							ii				=	0;
1372:stk500boot.c  **** 						}
1373:stk500boot.c  **** 						else
1374:stk500boot.c  **** 						{
1375:stk500boot.c  **** 							msgParseState	=	ST_START;
1376:stk500boot.c  **** 						}
1377:stk500boot.c  **** 						break;
1378:stk500boot.c  **** 						}
1379:stk500boot.c  **** 					case ST_GET_DATA:
1380:stk500boot.c  **** 					{
1381:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 1599               		.loc 1 1381 0
 1600 00c2 FE01      		movw r30,r28
 1601 00c4 3196      		adiw r30,1
 1602 00c6 1F01      		movw r2,r30
 1603               	.LVL137:
 1604               	.L71:
1219:stk500boot.c  **** 	boot_state	=	0;
 1605               		.loc 1 1219 0
 1606 00c8 10E0      		ldi r17,0
 1607 00ca 00E0      		ldi r16,0
 1608 00cc 00C0      		rjmp .L194
 1609               	.LVL138:
 1610               	.L69:
 1611               	.LBB112:
 1612               	.LBB113:
 1613               		.loc 2 187 0
 1614 00ce 85E0      		ldi r24,lo8(5)
 1615 00d0 8A95      	1:	dec r24
 1616 00d2 01F4      		brne 1b
 1617 00d4 0000      		nop
 1618               	.LVL139:
 1619               	.LBE113:
 1620               	.LBE112:
1240:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 1621               		.loc 1 1240 0
 1622 00d6 4F5F      		subi r20,-1
 1623 00d8 5F4F      		sbci r21,-1
 1624 00da 6F4F      		sbci r22,-1
 1625 00dc 7F4F      		sbci r23,-1
 1626               	.LVL140:
1241:stk500boot.c  **** 			{
 1627               		.loc 1 1241 0
 1628 00de 413E      		cpi r20,-31
 1629 00e0 97E6      		ldi r25,103
 1630 00e2 5907      		cpc r21,r25
 1631 00e4 95E3      		ldi r25,53
 1632 00e6 6907      		cpc r22,r25
 1633 00e8 7105      		cpc r23,__zero_reg__
 1634 00ea 00F0      		brlo .L70
1243:stk500boot.c  **** 			}
 1635               		.loc 1 1243 0
 1636 00ec C25E      		subi r28,lo8(-286)
 1637 00ee DE4F      		sbci r29,hi8(-286)
 1638 00f0 3983      		std Y+1,r19
 1639 00f2 2883      		st Y,r18
 1640 00f4 CE51      		subi r28,lo8(286)
 1641 00f6 D140      		sbci r29,hi8(286)
 1642               	.L70:
 1643               	.LBB114:
 1644               	.LBB115:
1012:stk500boot.c  **** }
 1645               		.loc 1 1012 0
 1646 00f8 E091 C000 		lds r30,192
 1647 00fc C25E      		subi r28,lo8(-286)
 1648 00fe DE4F      		sbci r29,hi8(-286)
 1649 0100 8881      		ld r24,Y
 1650 0102 9981      		ldd r25,Y+1
 1651 0104 CE51      		subi r28,lo8(286)
 1652 0106 D140      		sbci r29,hi8(286)
 1653               	.LBE115:
 1654               	.LBE114:
1237:stk500boot.c  **** 		{
 1655               		.loc 1 1237 0
 1656 0108 E7FD      		sbrc r30,7
 1657 010a 00C0      		rjmp .L68
1237:stk500boot.c  **** 		{
 1658               		.loc 1 1237 0 is_stmt 0 discriminator 1
 1659 010c 0097      		sbiw r24,0
 1660 010e 01F0      		breq .L69
 1661               	.L68:
1246:stk500boot.c  **** 	}
 1662               		.loc 1 1246 0 is_stmt 1
 1663 0110 0196      		adiw r24,1
 1664 0112 C25E      		subi r28,lo8(-286)
 1665 0114 DE4F      		sbci r29,hi8(-286)
 1666 0116 9983      		std Y+1,r25
 1667 0118 8883      		st Y,r24
 1668 011a CE51      		subi r28,lo8(286)
 1669 011c D140      		sbci r29,hi8(286)
 1670 011e 00C0      		rjmp .L66
 1671               	.LVL141:
 1672               	.L73:
1274:stk500boot.c  **** 		     {
 1673               		.loc 1 1274 0
 1674 0120 A1E0      		ldi r26,lo8(1)
 1675 0122 FA12      		cpse r15,r26
 1676 0124 00C0      		rjmp .L76
 1677               	.LBB116:
1276:stk500boot.c  **** 
 1678               		.loc 1 1276 0
 1679 0126 CE01      		movw r24,r28
 1680               	.LVL142:
 1681 0128 825E      		subi r24,-30
 1682 012a 9E4F      		sbci r25,-2
 1683 012c 0E94 0000 		call getData
 1684               	.LVL143:
 1685 0130 CA5D      		subi r28,lo8(-294)
 1686 0132 DE4F      		sbci r29,hi8(-294)
 1687 0134 8883      		st Y,r24
 1688 0136 C652      		subi r28,lo8(294)
 1689 0138 D140      		sbci r29,hi8(294)
 1690               	.LVL144:
 1691               	.L77:
 1692               	.LBE116:
1219:stk500boot.c  **** 	boot_state	=	0;
 1693               		.loc 1 1219 0
 1694 013a 32E0      		ldi r19,lo8(2)
 1695 013c F32E      		mov r15,r19
 1696               	.LVL145:
 1697               	.L145:
1266:stk500boot.c  **** 		     if (packetRetrieveState == SOTA_PACKET_RETRIEVE_START)
 1698               		.loc 1 1266 0
 1699 013e CE01      		movw r24,r28
 1700 0140 825E      		subi r24,-30
 1701 0142 9E4F      		sbci r25,-2
 1702 0144 0E94 0000 		call getData
 1703               	.LVL146:
1267:stk500boot.c  **** 		  	{
 1704               		.loc 1 1267 0
 1705 0148 F110      		cpse r15,__zero_reg__
 1706 014a 00C0      		rjmp .L73
 1707               	.LVL147:
1269:stk500boot.c  **** 		     {
 1708               		.loc 1 1269 0
 1709 014c FF24      		clr r15
 1710 014e F394      		inc r15
 1711 0150 8835      		cpi r24,lo8(88)
 1712 0152 01F0      		breq .L145
 1713               	.LVL148:
 1714               	.L194:
1219:stk500boot.c  **** 	boot_state	=	0;
 1715               		.loc 1 1219 0
 1716 0154 F12C      		mov r15,__zero_reg__
 1717 0156 00C0      		rjmp .L145
 1718               	.LVL149:
 1719               	.L76:
1282:stk500boot.c  **** 		     {
 1720               		.loc 1 1282 0
 1721 0158 B2E0      		ldi r27,lo8(2)
 1722 015a FB12      		cpse r15,r27
 1723 015c 00C0      		rjmp .L78
1284:stk500boot.c  **** 		       receivedPacket[packetRetrieveIndex] = c;
 1724               		.loc 1 1284 0
 1725 015e CA5D      		subi r28,lo8(-294)
 1726 0160 DE4F      		sbci r29,hi8(-294)
 1727 0162 E881      		ld r30,Y
 1728 0164 C652      		subi r28,lo8(294)
 1729 0166 D140      		sbci r29,hi8(294)
 1730 0168 E017      		cp r30,r16
 1731 016a 1106      		cpc __zero_reg__,r17
 1732 016c 01F0      		breq .L79
 1733 016e 04F0      		brlt .L79
1285:stk500boot.c  **** 		  		//sendchar(c);
 1734               		.loc 1 1285 0
 1735 0170 F801      		movw r30,r16
 1736 0172 E050      		subi r30,lo8(-(receivedPacket))
 1737 0174 F040      		sbci r31,hi8(-(receivedPacket))
 1738 0176 8083      		st Z,r24
1287:stk500boot.c  **** 		  	}
 1739               		.loc 1 1287 0
 1740 0178 0F5F      		subi r16,-1
 1741 017a 1F4F      		sbci r17,-1
 1742               	.LVL150:
 1743 017c 00C0      		rjmp .L77
 1744               	.L78:
1263:stk500boot.c  **** 		   {
 1745               		.loc 1 1263 0
 1746 017e F3E0      		ldi r31,lo8(3)
 1747 0180 FF12      		cpse r15,r31
 1748 0182 00C0      		rjmp .L145
 1749               	.L79:
 1750               	.LVL151:
1301:stk500boot.c  ****   // sendchar(0x34);
 1751               		.loc 1 1301 0
 1752 0184 CA5D      		subi r28,lo8(-294)
 1753 0186 DE4F      		sbci r29,hi8(-294)
 1754 0188 2881      		ld r18,Y
 1755 018a C652      		subi r28,lo8(294)
 1756 018c D140      		sbci r29,hi8(294)
 1757 018e E22E      		mov r14,r18
 1758 0190 F12C      		mov r15,__zero_reg__
 1759               	.LVL152:
 1760               	.LBB117:
 1761               	.LBB118:
 881:stk500boot.c  **** 
 1762               		.loc 1 881 0
 1763 0192 2F70      		andi r18,lo8(15)
 1764 0194 A22E      		mov r10,r18
 1765               	.LVL153:
 886:stk500boot.c  ****     KeyExpansion();
 1766               		.loc 1 886 0
 1767 0196 80E0      		ldi r24,lo8(key)
 1768 0198 90E0      		ldi r25,hi8(key)
 1769               	.LVL154:
 1770 019a 9093 0000 		sts Key+1,r25
 1771 019e 8093 0000 		sts Key,r24
 887:stk500boot.c  ****   }
 1772               		.loc 1 887 0
 1773 01a2 0E94 0000 		call KeyExpansion
 1774               	.LVL155:
 893:stk500boot.c  ****   }
 1775               		.loc 1 893 0
 1776 01a6 A0E0      		ldi r26,lo8(iv)
 1777 01a8 B0E0      		ldi r27,hi8(iv)
 1778 01aa B093 0000 		sts Iv+1,r27
 1779 01ae A093 0000 		sts Iv,r26
 1780               	.LVL156:
 1781 01b2 B0E0      		ldi r27,lo8(receivedPacket)
 1782 01b4 CB2E      		mov r12,r27
 1783 01b6 B0E0      		ldi r27,hi8(receivedPacket)
 1784 01b8 DB2E      		mov r13,r27
 1785 01ba 00E0      		ldi r16,lo8(aes_buffer)
 1786 01bc 10E0      		ldi r17,hi8(aes_buffer)
 1787               	.LVL157:
 1788               	.L80:
 896:stk500boot.c  ****   {
 1789               		.loc 1 896 0
 1790 01be C801      		movw r24,r16
 1791 01c0 8050      		subi r24,lo8(aes_buffer)
 1792 01c2 9040      		sbci r25,hi8(aes_buffer)
 1793               	.LVL158:
 1794 01c4 8E15      		cp r24,r14
 1795 01c6 9F05      		cpc r25,r15
 1796 01c8 00F0      		brlo .L81
 907:stk500boot.c  ****   {
 1797               		.loc 1 907 0
 1798 01ca AA20      		tst r10
 1799 01cc 01F0      		breq .L82
 909:stk500boot.c  ****     state = (state_t*)output;
 1800               		.loc 1 909 0
 1801 01ce 4A2D      		mov r20,r10
 1802 01d0 50E0      		ldi r21,0
 1803 01d2 B601      		movw r22,r12
 1804 01d4 C801      		movw r24,r16
 1805               	.LVL159:
 1806 01d6 0E94 0000 		call memcpy
 1807               	.LVL160:
 910:stk500boot.c  ****     InvCipher();
 1808               		.loc 1 910 0
 1809 01da 1093 0000 		sts state+1,r17
 1810 01de 0093 0000 		sts state,r16
 911:stk500boot.c  ****   }
 1811               		.loc 1 911 0
 1812 01e2 0E94 0000 		call InvCipher
 1813               	.LVL161:
 1814               	.L82:
 893:stk500boot.c  ****   }
 1815               		.loc 1 893 0
 1816 01e6 E0E0      		ldi r30,lo8(aes_buffer)
 1817 01e8 F0E0      		ldi r31,hi8(aes_buffer)
 1818 01ea 90E0      		ldi r25,0
 1819 01ec 80E0      		ldi r24,0
 1820               	.LVL162:
 1821               	.L195:
 1822 01ee 40E0      		ldi r20,0
 1823               	.L83:
 1824               	.LVL163:
 1825               	.LBE118:
 1826               	.LBE117:
1315:stk500boot.c  **** 				  // sendchar(c);
 1827               		.loc 1 1315 0
 1828 01f0 5191      		ld r21,Z+
 1829               	.LVL164:
1318:stk500boot.c  **** 				{
 1830               		.loc 1 1318 0
 1831 01f2 4330      		cpi r20,lo8(3)
 1832 01f4 01F0      		breq .L85
 1833 01f6 00F4      		brsh .L86
 1834 01f8 4130      		cpi r20,lo8(1)
 1835 01fa 01F0      		breq .L87
 1836 01fc 00F0      		brlo .L192
1351:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 1837               		.loc 1 1351 0
 1838 01fe 852F      		mov r24,r21
 1839               	.LVL165:
 1840 0200 90E0      		ldi r25,0
 1841 0202 982F      		mov r25,r24
 1842 0204 8827      		clr r24
 1843               	.LVL166:
1353:stk500boot.c  **** 						break;
 1844               		.loc 1 1353 0
 1845 0206 B526      		eor r11,r21
 1846               	.LVL167:
1352:stk500boot.c  **** 						checksum		^=	c;
 1847               		.loc 1 1352 0
 1848 0208 43E0      		ldi r20,lo8(3)
1354:stk500boot.c  **** 					}
 1849               		.loc 1 1354 0
 1850 020a 00C0      		rjmp .L83
 1851               	.LVL168:
 1852               	.L81:
 1853               	.LBB120:
 1854               	.LBB119:
 898:stk500boot.c  ****     state = (state_t*)output;
 1855               		.loc 1 898 0
 1856 020c 80E1      		ldi r24,lo8(16)
 1857               	.LVL169:
 1858 020e F601      		movw r30,r12
 1859 0210 D801      		movw r26,r16
 1860               		0:
 1861 0212 0190      		ld r0,Z+
 1862 0214 0D92      		st X+,r0
 1863 0216 8A95      		dec r24
 1864 0218 01F4      		brne 0b
 899:stk500boot.c  ****     InvCipher();
 1865               		.loc 1 899 0
 1866 021a 1093 0000 		sts state+1,r17
 1867 021e 0093 0000 		sts state,r16
 900:stk500boot.c  ****     XorWithIv(output);
 1868               		.loc 1 900 0
 1869 0222 0E94 0000 		call InvCipher
 1870               	.LVL170:
 901:stk500boot.c  ****     Iv = input;
 1871               		.loc 1 901 0
 1872 0226 C801      		movw r24,r16
 1873 0228 0E94 0000 		call XorWithIv
 1874               	.LVL171:
 902:stk500boot.c  ****     input += BLOCKLEN;
 1875               		.loc 1 902 0
 1876 022c D092 0000 		sts Iv+1,r13
 1877 0230 C092 0000 		sts Iv,r12
 903:stk500boot.c  ****     output += BLOCKLEN;
 1878               		.loc 1 903 0
 1879 0234 B0E1      		ldi r27,16
 1880 0236 CB0E      		add r12,r27
 1881 0238 D11C      		adc r13,__zero_reg__
 1882               	.LVL172:
 904:stk500boot.c  ****   }
 1883               		.loc 1 904 0
 1884 023a 005F      		subi r16,-16
 1885 023c 1F4F      		sbci r17,-1
 1886               	.LVL173:
 1887 023e 00C0      		rjmp .L80
 1888               	.LVL174:
 1889               	.L86:
 1890               	.LBE119:
 1891               	.LBE120:
1318:stk500boot.c  **** 				{
 1892               		.loc 1 1318 0
 1893 0240 4530      		cpi r20,lo8(5)
 1894 0242 01F0      		breq .L90
 1895 0244 00F0      		brlo .L91
 1896 0246 4630      		cpi r20,lo8(6)
 1897 0248 01F0      		breq .L92
1313:stk500boot.c  **** 			{
 1898               		.loc 1 1313 0
 1899 024a 4730      		cpi r20,lo8(7)
 1900 024c 01F4      		brne .L83
 1901 024e 00C0      		rjmp .L94
 1902               	.L192:
 1903               	.LVL175:
1322:stk500boot.c  **** 						{
 1904               		.loc 1 1322 0
 1905 0250 5B31      		cpi r21,lo8(27)
 1906 0252 01F4      		brne .L83
1325:stk500boot.c  **** 						}
 1907               		.loc 1 1325 0
 1908 0254 2BE1      		ldi r18,lo8(27)
 1909 0256 B22E      		mov r11,r18
 1910               	.LVL176:
1324:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 1911               		.loc 1 1324 0
 1912 0258 41E0      		ldi r20,lo8(1)
 1913 025a 00C0      		rjmp .L83
 1914               	.LVL177:
 1915               	.L87:
1333:stk500boot.c  **** 					#else
 1916               		.loc 1 1333 0
 1917 025c B526      		eor r11,r21
 1918               	.LVL178:
1315:stk500boot.c  **** 				  // sendchar(c);
 1919               		.loc 1 1315 0
 1920 025e CB5D      		subi r28,lo8(-293)
 1921 0260 DE4F      		sbci r29,hi8(-293)
 1922 0262 5883      		st Y,r21
 1923 0264 C552      		subi r28,lo8(293)
 1924 0266 D140      		sbci r29,hi8(293)
1332:stk500boot.c  **** 						checksum		^=	c;
 1925               		.loc 1 1332 0
 1926 0268 42E0      		ldi r20,lo8(2)
1346:stk500boot.c  **** 					}
 1927               		.loc 1 1346 0
 1928 026a 00C0      		rjmp .L83
 1929               	.LVL179:
 1930               	.L85:
1359:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 1931               		.loc 1 1359 0
 1932 026c 852B      		or r24,r21
 1933               	.LVL180:
1361:stk500boot.c  **** 						break;
 1934               		.loc 1 1361 0
 1935 026e B526      		eor r11,r21
 1936               	.LVL181:
1360:stk500boot.c  **** 						checksum		^=	c;
 1937               		.loc 1 1360 0
 1938 0270 44E0      		ldi r20,lo8(4)
1362:stk500boot.c  **** 					}
 1939               		.loc 1 1362 0
 1940 0272 00C0      		rjmp .L83
 1941               	.LVL182:
 1942               	.L91:
1367:stk500boot.c  **** 						{
 1943               		.loc 1 1367 0
 1944 0274 5E30      		cpi r21,lo8(14)
 1945 0276 01F0      		breq .+2
 1946 0278 00C0      		rjmp .L195
 1947               	.LVL183:
1370:stk500boot.c  **** 							ii				=	0;
 1948               		.loc 1 1370 0
 1949 027a B526      		eor r11,r21
 1950               	.LVL184:
1371:stk500boot.c  **** 						}
 1951               		.loc 1 1371 0
 1952 027c 912C      		mov r9,__zero_reg__
 1953 027e 812C      		mov r8,__zero_reg__
1369:stk500boot.c  **** 							checksum		^=	c;
 1954               		.loc 1 1369 0
 1955 0280 45E0      		ldi r20,lo8(5)
 1956 0282 00C0      		rjmp .L83
 1957               	.LVL185:
 1958               	.L90:
 1959               		.loc 1 1381 0
 1960 0284 9401      		movw r18,r8
 1961 0286 2F5F      		subi r18,-1
 1962 0288 3F4F      		sbci r19,-1
 1963               	.LVL186:
 1964 028a D101      		movw r26,r2
 1965 028c A80D      		add r26,r8
 1966 028e B91D      		adc r27,r9
 1967 0290 5C93      		st X,r21
1382:stk500boot.c  **** 						checksum		^=	c;
 1968               		.loc 1 1382 0
 1969 0292 B526      		eor r11,r21
 1970               	.LVL187:
1383:stk500boot.c  **** 						if (ii == msgLength )
 1971               		.loc 1 1383 0
 1972 0294 4901      		movw r8,r18
 1973 0296 2817      		cp r18,r24
 1974 0298 3907      		cpc r19,r25
 1975 029a 01F0      		breq .+2
 1976 029c 00C0      		rjmp .L83
 1977 029e 4C01      		movw r8,r24
1384:stk500boot.c  **** 						{
1385:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 1978               		.loc 1 1385 0
 1979 02a0 46E0      		ldi r20,lo8(6)
 1980               	.LVL188:
 1981 02a2 00C0      		rjmp .L83
 1982               	.LVL189:
 1983               	.L92:
1386:stk500boot.c  **** 						}
1387:stk500boot.c  **** 						break;
1388:stk500boot.c  **** 					}
1389:stk500boot.c  **** 
1390:stk500boot.c  **** 					case ST_GET_CHECK:
1391:stk500boot.c  **** 					{
1392:stk500boot.c  **** 						if ( c == checksum )
 1984               		.loc 1 1392 0
 1985 02a4 5B11      		cpse r21,r11
 1986 02a6 00C0      		rjmp .L195
 1987               	.LVL190:
 1988               	.L94:
1393:stk500boot.c  **** 						{
1394:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
1395:stk500boot.c  **** 						}
1396:stk500boot.c  **** 						else
1397:stk500boot.c  **** 						{
1398:stk500boot.c  **** 							msgParseState	=	ST_START;
1399:stk500boot.c  **** 						}
1400:stk500boot.c  **** 						break;
1401:stk500boot.c  **** 					}
1402:stk500boot.c  **** 				}	//	switch
1403:stk500boot.c  **** 				receivedPacketIndex++;
1404:stk500boot.c  **** 			}	//	while(msgParseState)
1405:stk500boot.c  **** 			/*
1406:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
1407:stk500boot.c  **** 			 */
1408:stk500boot.c  **** 
1409:stk500boot.c  **** 			// 	for(int i=0; i<msgLength;i++)
1410:stk500boot.c  **** 			// 	sendchar(msgBuffer[i]);
1411:stk500boot.c  **** 			// sendchar(0x61);
1412:stk500boot.c  **** /*
1413:stk500boot.c  **** 
1414:stk500boot.c  **** union{
1415:stk500boot.c  **** 	float authenticationNumber;
1416:stk500boot.c  **** 	char authBytes[4]
1417:stk500boot.c  **** }authenticationToken;
1418:stk500boot.c  **** 
1419:stk500boot.c  **** */
1420:stk500boot.c  **** 
1421:stk500boot.c  **** 			switch (msgBuffer[0])
 1989               		.loc 1 1421 0
 1990 02a8 4981      		ldd r20,Y+1
 1991 02aa 4331      		cpi r20,lo8(19)
 1992 02ac 01F4      		brne .+2
 1993 02ae 00C0      		rjmp .L97
 1994 02b0 00F4      		brsh .L98
 1995 02b2 4630      		cpi r20,lo8(6)
 1996 02b4 01F4      		brne .+2
 1997 02b6 00C0      		rjmp .L99
 1998 02b8 00F4      		brsh .L100
 1999 02ba 4230      		cpi r20,lo8(2)
 2000 02bc 01F4      		brne .+2
 2001 02be 00C0      		rjmp .L101
 2002 02c0 4330      		cpi r20,lo8(3)
 2003 02c2 01F4      		brne .+2
 2004 02c4 00C0      		rjmp .L102
 2005 02c6 4130      		cpi r20,lo8(1)
 2006 02c8 01F4      		brne .L96
1422:stk500boot.c  **** 			{
1423:stk500boot.c  **** 	// #ifndef AUTHENTICATION
1424:stk500boot.c  **** 				case CMD_AUTH:
1425:stk500boot.c  **** 				{
1426:stk500boot.c  **** 
1427:stk500boot.c  **** 					if((msgBuffer[5] == authenticationToken[0]) && (msgBuffer[6] == authenticationToken[1]) && (ms
1428:stk500boot.c  **** 					{
1429:stk500boot.c  **** 						authenticationNumber.authBytes[0] = msgBuffer[1];
1430:stk500boot.c  **** 						authenticationNumber.authBytes[1] = msgBuffer[2];
1431:stk500boot.c  **** 						authenticationNumber.authBytes[2] = msgBuffer[3];
1432:stk500boot.c  **** 						authenticationNumber.authBytes[3] = msgBuffer[4];
1433:stk500boot.c  **** 
1434:stk500boot.c  **** 						//PrintDecInt((uint32_t)msgBuffer[4]);
1435:stk500boot.c  **** 						uint32_t number = (((uint32_t)msgBuffer[4])); // i dont have any idea why it's working.
1436:stk500boot.c  **** 
1437:stk500boot.c  **** 						authenticationNumber.authenticationNumber = authenticationNumber.authenticationNumber +  numb
1438:stk500boot.c  **** 
1439:stk500boot.c  **** 						msgBuffer[0] = STATUS_CMD_OK;
1440:stk500boot.c  **** 						msgBuffer[1] = authenticationNumber.authBytes[0];
1441:stk500boot.c  **** 						msgBuffer[2] = authenticationNumber.authBytes[1];
1442:stk500boot.c  **** 						msgBuffer[3] = authenticationNumber.authBytes[2];
1443:stk500boot.c  **** 						msgBuffer[4] = authenticationNumber.authBytes[3];
1444:stk500boot.c  **** 
1445:stk500boot.c  **** 						msgLength = 5;
1446:stk500boot.c  **** 						isAuthenticated = 0x01;
1447:stk500boot.c  **** 
1448:stk500boot.c  **** 					}
1449:stk500boot.c  **** 					else
1450:stk500boot.c  **** 					{
1451:stk500boot.c  **** 							msgBuffer[0] = STATUS_CMD_FAILED;
1452:stk500boot.c  **** 							msgLength = 1;
1453:stk500boot.c  **** 							isAuthenticated = 0x00;
1454:stk500boot.c  **** 					}
1455:stk500boot.c  **** 					break;
1456:stk500boot.c  **** 				}
1457:stk500boot.c  **** 	// #endif
1458:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
1459:stk500boot.c  **** 				case CMD_SPI_MULTI:
1460:stk500boot.c  **** 					{
1461:stk500boot.c  **** 						if(isAuthenticated){
1462:stk500boot.c  **** 						unsigned char answerByte;
1463:stk500boot.c  **** 						unsigned char flag=0;
1464:stk500boot.c  **** 
1465:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
1466:stk500boot.c  **** 						{
1467:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
1468:stk500boot.c  **** 
1469:stk500boot.c  **** 							if ( signatureIndex == 0 )
1470:stk500boot.c  **** 							{
1471:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
1472:stk500boot.c  **** 							}
1473:stk500boot.c  **** 							else if ( signatureIndex == 1 )
1474:stk500boot.c  **** 							{
1475:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
1476:stk500boot.c  **** 							}
1477:stk500boot.c  **** 							else
1478:stk500boot.c  **** 							{
1479:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
1480:stk500boot.c  **** 							}
1481:stk500boot.c  **** 						}
1482:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
1483:stk500boot.c  **** 						{
1484:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
1485:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
1486:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1487:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1488:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1489:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
1490:stk500boot.c  **** 							{
1491:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1492:stk500boot.c  **** 							}
1493:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
1494:stk500boot.c  **** 							{
1495:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1496:stk500boot.c  **** 							}
1497:stk500boot.c  **** 							else
1498:stk500boot.c  **** 							{
1499:stk500boot.c  **** 								answerByte	=	0;
1500:stk500boot.c  **** 							}
1501:stk500boot.c  **** 						}
1502:stk500boot.c  **** 						else
1503:stk500boot.c  **** 						{
1504:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
1505:stk500boot.c  **** 						}
1506:stk500boot.c  **** 						if ( !flag )
1507:stk500boot.c  **** 						{
1508:stk500boot.c  **** 							msgLength		=	7;
1509:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
1510:stk500boot.c  **** 							msgBuffer[2]	=	0;
1511:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
1512:stk500boot.c  **** 							msgBuffer[4]	=	0;
1513:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
1514:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
1515:stk500boot.c  **** 						}
1516:stk500boot.c  **** 					}
1517:stk500boot.c  **** 					}
1518:stk500boot.c  **** 					break;
1519:stk500boot.c  **** 	#endif
1520:stk500boot.c  **** 				case CMD_SIGN_ON:
1521:stk500boot.c  **** 				{
1522:stk500boot.c  **** 					if(isAuthenticated){
 2007               		.loc 1 1522 0
 2008 02ca CC5D      		subi r28,lo8(-292)
 2009 02cc DE4F      		sbci r29,hi8(-292)
 2010 02ce F881      		ld r31,Y
 2011 02d0 C452      		subi r28,lo8(292)
 2012 02d2 D140      		sbci r29,hi8(292)
 2013 02d4 FF23      		tst r31
 2014 02d6 01F4      		brne .+2
 2015 02d8 00C0      		rjmp .L114
 2016               	.LVL191:
1523:stk500boot.c  **** 					// sendchar(0x62);
1524:stk500boot.c  **** 					msgLength		=	11;
1525:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 2017               		.loc 1 1525 0
 2018 02da 1A82      		std Y+2,__zero_reg__
1526:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 2019               		.loc 1 1526 0
 2020 02dc 88E0      		ldi r24,lo8(8)
 2021 02de 8B83      		std Y+3,r24
1527:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 2022               		.loc 1 1527 0
 2023 02e0 81E4      		ldi r24,lo8(65)
 2024 02e2 8C83      		std Y+4,r24
1528:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 2025               		.loc 1 1528 0
 2026 02e4 86E5      		ldi r24,lo8(86)
 2027 02e6 8D83      		std Y+5,r24
1529:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 2028               		.loc 1 1529 0
 2029 02e8 82E5      		ldi r24,lo8(82)
 2030 02ea 8E83      		std Y+6,r24
1530:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 2031               		.loc 1 1530 0
 2032 02ec 89E4      		ldi r24,lo8(73)
 2033 02ee 8F83      		std Y+7,r24
1531:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 2034               		.loc 1 1531 0
 2035 02f0 83E5      		ldi r24,lo8(83)
 2036 02f2 8887      		std Y+8,r24
1532:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 2037               		.loc 1 1532 0
 2038 02f4 80E5      		ldi r24,lo8(80)
 2039 02f6 8987      		std Y+9,r24
1533:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 2040               		.loc 1 1533 0
 2041 02f8 8FE5      		ldi r24,lo8(95)
 2042 02fa 8A87      		std Y+10,r24
1534:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 2043               		.loc 1 1534 0
 2044 02fc 82E3      		ldi r24,lo8(50)
 2045 02fe 8B87      		std Y+11,r24
 2046 0300 A12C      		mov r10,__zero_reg__
 2047               	.LVL192:
1524:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 2048               		.loc 1 1524 0
 2049 0302 8BE0      		ldi r24,lo8(11)
 2050 0304 90E0      		ldi r25,0
 2051 0306 00C0      		rjmp .L113
 2052               	.LVL193:
 2053               	.L100:
1421:stk500boot.c  **** 			{
 2054               		.loc 1 1421 0
 2055 0308 4131      		cpi r20,lo8(17)
 2056 030a 01F4      		brne .+2
 2057 030c 00C0      		rjmp .L150
 2058 030e 00F0      		brlo .+2
 2059 0310 00C0      		rjmp .L105
 2060 0312 4031      		cpi r20,lo8(16)
 2061 0314 01F4      		brne .+2
 2062 0316 00C0      		rjmp .L101
 2063               	.L96:
 2064               	.LVL194:
1535:stk500boot.c  **** 				}
1536:stk500boot.c  **** 				else
1537:stk500boot.c  **** 				{
1538:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_FAILED;
1539:stk500boot.c  **** 					msgLength		=	1;
1540:stk500boot.c  **** 				}
1541:stk500boot.c  **** 					break;
1542:stk500boot.c  **** 				}
1543:stk500boot.c  **** 
1544:stk500boot.c  **** 				case CMD_GET_PARAMETER:
1545:stk500boot.c  **** 					{
1546:stk500boot.c  **** 						unsigned char value;
1547:stk500boot.c  **** 
1548:stk500boot.c  **** 						switch(msgBuffer[1])
1549:stk500boot.c  **** 						{
1550:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
1551:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
1552:stk500boot.c  **** 							break;
1553:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
1554:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
1555:stk500boot.c  **** 							break;
1556:stk500boot.c  **** 						case PARAM_HW_VER:
1557:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
1558:stk500boot.c  **** 							break;
1559:stk500boot.c  **** 						case PARAM_SW_MAJOR:
1560:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
1561:stk500boot.c  **** 							break;
1562:stk500boot.c  **** 						case PARAM_SW_MINOR:
1563:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
1564:stk500boot.c  **** 							break;
1565:stk500boot.c  **** 						default:
1566:stk500boot.c  **** 							value	=	0;
1567:stk500boot.c  **** 							break;
1568:stk500boot.c  **** 						}
1569:stk500boot.c  **** 						msgLength		=	3;
1570:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1571:stk500boot.c  **** 						msgBuffer[2]	=	value;
1572:stk500boot.c  **** 					}
1573:stk500boot.c  **** 					break;
1574:stk500boot.c  **** 
1575:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
1576:stk500boot.c  **** 					isLeave	=	1;
1577:stk500boot.c  **** 					//*	fall thru
1578:stk500boot.c  **** 
1579:stk500boot.c  **** 				case CMD_SET_PARAMETER:
1580:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
1581:stk500boot.c  **** 				if(isAuthenticated){
1582:stk500boot.c  **** 					msgLength		=	2;
1583:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1584:stk500boot.c  **** 				}
1585:stk500boot.c  **** 					break;
1586:stk500boot.c  **** 
1587:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
1588:stk500boot.c  **** 					{
1589:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
1590:stk500boot.c  **** 						unsigned char signature;
1591:stk500boot.c  **** 
1592:stk500boot.c  **** 						if ( signatureIndex == 0 )
1593:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
1594:stk500boot.c  **** 						else if ( signatureIndex == 1 )
1595:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
1596:stk500boot.c  **** 						else
1597:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
1598:stk500boot.c  **** 
1599:stk500boot.c  **** 						msgLength		=	4;
1600:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1601:stk500boot.c  **** 						msgBuffer[2]	=	signature;
1602:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1603:stk500boot.c  **** 					}
1604:stk500boot.c  **** 					break;
1605:stk500boot.c  **** 
1606:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
1607:stk500boot.c  **** 					msgLength		=	4;
1608:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1609:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
1610:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
1611:stk500boot.c  **** 					break;
1612:stk500boot.c  **** 
1613:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
1614:stk500boot.c  **** 					{
1615:stk500boot.c  **** 						unsigned char fuseBits;
1616:stk500boot.c  **** 
1617:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
1618:stk500boot.c  **** 						{
1619:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
1620:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
1621:stk500boot.c  **** 							else
1622:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
1623:stk500boot.c  **** 						}
1624:stk500boot.c  **** 						else
1625:stk500boot.c  **** 						{
1626:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
1627:stk500boot.c  **** 						}
1628:stk500boot.c  **** 						msgLength		=	4;
1629:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1630:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
1631:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1632:stk500boot.c  **** 					}
1633:stk500boot.c  **** 					break;
1634:stk500boot.c  **** 
1635:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1636:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
1637:stk500boot.c  **** 					{
1638:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
1639:stk500boot.c  **** 
1640:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
1641:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
1642:stk500boot.c  **** 						boot_spm_busy_wait();
1643:stk500boot.c  **** 
1644:stk500boot.c  **** 						msgLength		=	3;
1645:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1646:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
1647:stk500boot.c  **** 					}
1648:stk500boot.c  **** 					break;
1649:stk500boot.c  **** 	#endif
1650:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
1651:stk500boot.c  **** 					eraseAddress	=	0;
1652:stk500boot.c  **** 					msgLength		=	2;
1653:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1654:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
1655:stk500boot.c  **** 					break;
1656:stk500boot.c  **** 
1657:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
1658:stk500boot.c  **** 	#if defined(RAMPZ)
1659:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1660:stk500boot.c  **** 	#else
1661:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1662:stk500boot.c  **** 	#endif
1663:stk500boot.c  **** 					msgLength		=	2;
1664:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1665:stk500boot.c  **** 					break;
1666:stk500boot.c  **** 
1667:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1668:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1669:stk500boot.c  **** 					{
1670:stk500boot.c  **** 						if(isAuthenticated){
1671:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2]; // ok
1672:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1673:stk500boot.c  **** 
1674:stk500boot.c  **** 						unsigned int	data;
1675:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1676:stk500boot.c  **** 
1677:stk500boot.c  **** 						address_t		tempaddress	=	address;
1678:stk500boot.c  **** 
1679:stk500boot.c  **** 	  					if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1680:stk500boot.c  **** 						{
1681:stk500boot.c  **** 							// erase only main section (bootloader protection)
1682:stk500boot.c  **** 							if (eraseAddress < APP_END )
1683:stk500boot.c  **** 							{
1684:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1685:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1686:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1687:stk500boot.c  **** 							}
1688:stk500boot.c  **** 
1689:stk500boot.c  **** 							/* Write FLASH */
1690:stk500boot.c  **** 							do {
1691:stk500boot.c  **** 
1692:stk500boot.c  **** 								lowByte		=	*p++;
1693:stk500boot.c  **** 								highByte 	=	*p++;
1694:stk500boot.c  **** 
1695:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1696:stk500boot.c  **** 								boot_page_fill(address,data);
1697:stk500boot.c  **** 
1698:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1699:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1700:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1701:stk500boot.c  **** 
1702:stk500boot.c  **** 							boot_page_write(tempaddress);
1703:stk500boot.c  **** 							boot_spm_busy_wait();
1704:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1705:stk500boot.c  **** 						}
1706:stk500boot.c  **** 						else
1707:stk500boot.c  **** 						{
1708:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1709:stk500boot.c  **** 							uint16_t ii = address >> 1;
1710:stk500boot.c  **** 							/* write EEPROM */
1711:stk500boot.c  **** 							while (size) {
1712:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1713:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1714:stk500boot.c  **** 								ii++;
1715:stk500boot.c  **** 								size--;
1716:stk500boot.c  **** 							}
1717:stk500boot.c  **** 						}
1718:stk500boot.c  **** 						msgLength		=	2;
1719:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1720:stk500boot.c  **** 					}
1721:stk500boot.c  **** 							break;
1722:stk500boot.c  **** 				}
1723:stk500boot.c  **** 
1724:stk500boot.c  **** 
1725:stk500boot.c  **** 
1726:stk500boot.c  **** 
1727:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1728:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1729:stk500boot.c  **** 					{
1730:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1731:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1732:stk500boot.c  **** 						msgLength				=	size+3;
1733:stk500boot.c  **** 
1734:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1735:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1736:stk500boot.c  **** 						{
1737:stk500boot.c  **** 							unsigned int data;
1738:stk500boot.c  **** 
1739:stk500boot.c  **** 							// Read FLASH
1740:stk500boot.c  **** 							do {
1741:stk500boot.c  **** 						//#if defined(RAMPZ)
1742:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1743:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1744:stk500boot.c  **** 						#else
1745:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1746:stk500boot.c  **** 						#endif
1747:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1748:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1749:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1750:stk500boot.c  **** 								size	-=	2;
1751:stk500boot.c  **** 							}while (size);
1752:stk500boot.c  **** 						}
1753:stk500boot.c  **** 						else
1754:stk500boot.c  **** 						{
1755:stk500boot.c  **** 							/* Read EEPROM */
1756:stk500boot.c  **** 							do {
1757:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1758:stk500boot.c  **** 								EEARH	=	((address >> 8));
1759:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1760:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1761:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1762:stk500boot.c  **** 								size--;
1763:stk500boot.c  **** 							} while (size);
1764:stk500boot.c  **** 						}
1765:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1766:stk500boot.c  **** 					}
1767:stk500boot.c  **** 					break;
1768:stk500boot.c  **** 
1769:stk500boot.c  **** 				default:
1770:stk500boot.c  **** 					msgLength		=	2;
1771:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 2065               		.loc 1 1771 0
 2066 0318 80EC      		ldi r24,lo8(-64)
 2067 031a 8A83      		std Y+2,r24
 2068 031c 00C0      		rjmp .L198
 2069               	.LVL195:
 2070               	.L98:
1421:stk500boot.c  **** 			{
 2071               		.loc 1 1421 0
 2072 031e 4831      		cpi r20,lo8(24)
 2073 0320 01F4      		brne .+2
 2074 0322 00C0      		rjmp .L106
 2075 0324 00F4      		brsh .L107
 2076 0326 4531      		cpi r20,lo8(21)
 2077 0328 01F4      		brne .+2
 2078 032a 00C0      		rjmp .L97
 2079 032c 00F0      		brlo .L108
 2080 032e 4631      		cpi r20,lo8(22)
 2081 0330 01F4      		brne .L96
 2082               	.L108:
 2083 0332 2A81      		ldd r18,Y+2
 2084 0334 3B81      		ldd r19,Y+3
 2085 0336 3227      		eor r19,r18
 2086 0338 2327      		eor r18,r19
 2087 033a 3227      		eor r19,r18
 2088               	.LVL196:
 2089               	.LBB121:
1732:stk500boot.c  **** 
 2090               		.loc 1 1732 0
 2091 033c C901      		movw r24,r18
 2092               	.LVL197:
 2093 033e 0396      		adiw r24,3
 2094               	.LVL198:
1734:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 2095               		.loc 1 1734 0
 2096 0340 1A82      		std Y+2,__zero_reg__
1735:stk500boot.c  **** 						{
 2097               		.loc 1 1735 0
 2098 0342 4431      		cpi r20,lo8(20)
 2099 0344 01F0      		breq .+2
 2100 0346 00C0      		rjmp .L129
 2101 0348 D101      		movw r26,r2
 2102               	.LVL199:
 2103               	.L130:
 2104               	.LBB122:
 2105               	.LBB123:
1743:stk500boot.c  **** 						#else
 2106               		.loc 1 1743 0 discriminator 1
 2107               	/* #APP */
 2108               	 ;  1743 "stk500boot.c" 1
 2109 034a 6BBE      		out 59, r6
 2110 034c F201      		movw r30, r4
 2111 034e 4791      		elpm r20, Z+
 2112 0350 5691      		elpm r21, Z
 2113               		
 2114               	 ;  0 "" 2
 2115               	.LVL200:
 2116               	/* #NOAPP */
 2117               	.LBE123:
1747:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 2118               		.loc 1 1747 0 discriminator 1
 2119 0352 1296      		adiw r26,2
 2120 0354 4C93      		st X,r20
 2121 0356 1297      		sbiw r26,2
 2122 0358 FD01      		movw r30,r26
 2123 035a 3496      		adiw r30,4
 2124               	.LVL201:
1748:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 2125               		.loc 1 1748 0 discriminator 1
 2126 035c 1396      		adiw r26,3
 2127 035e 5C93      		st X,r21
 2128 0360 1397      		sbiw r26,3
1749:stk500boot.c  **** 								size	-=	2;
 2129               		.loc 1 1749 0 discriminator 1
 2130 0362 42E0      		ldi r20,2
 2131 0364 440E      		add r4,r20
 2132 0366 511C      		adc r5,__zero_reg__
 2133 0368 611C      		adc r6,__zero_reg__
 2134 036a 711C      		adc r7,__zero_reg__
 2135               	.LVL202:
1750:stk500boot.c  **** 							}while (size);
 2136               		.loc 1 1750 0 discriminator 1
 2137 036c 2250      		subi r18,2
 2138 036e 3109      		sbc r19,__zero_reg__
 2139               	.LVL203:
 2140 0370 1296      		adiw r26,2
1751:stk500boot.c  **** 						}
 2141               		.loc 1 1751 0 discriminator 1
 2142 0372 2115      		cp r18,__zero_reg__
 2143 0374 3105      		cpc r19,__zero_reg__
 2144 0376 01F4      		brne .L130
 2145               	.LVL204:
 2146               	.L131:
 2147               	.LBE122:
1765:stk500boot.c  **** 					}
 2148               		.loc 1 1765 0
 2149 0378 1082      		st Z,__zero_reg__
 2150               	.LVL205:
 2151               	.L154:
 2152               	.LBE121:
 2153 037a A12C      		mov r10,__zero_reg__
 2154               	.LVL206:
 2155 037c 00C0      		rjmp .L113
 2156               	.LVL207:
 2157               	.L107:
1421:stk500boot.c  **** 			{
 2158               		.loc 1 1421 0
 2159 037e 4B31      		cpi r20,lo8(27)
 2160 0380 01F4      		brne .+2
 2161 0382 00C0      		rjmp .L109
 2162 0384 4736      		cpi r20,lo8(103)
 2163 0386 01F0      		breq .L110
 2164 0388 4A31      		cpi r20,lo8(26)
 2165 038a 01F0      		breq .+2
 2166 038c 00C0      		rjmp .L96
 2167               	.LVL208:
1608:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 2168               		.loc 1 1608 0
 2169 038e 1A82      		std Y+2,__zero_reg__
 2170               	.LBB124:
1609:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 2171               		.loc 1 1609 0
 2172 0390 89E0      		ldi r24,lo8(9)
 2173 0392 E1E0      		ldi r30,lo8(1)
 2174 0394 F0E0      		ldi r31,0
 2175               	.LVL209:
 2176               	/* #APP */
 2177               	 ;  1609 "stk500boot.c" 1
 2178 0396 8093 5700 		sts 87, r24
 2179 039a 8491      		lpm r24, Z
 2180               		
 2181               	 ;  0 "" 2
 2182               	/* #NOAPP */
 2183               	.L199:
 2184               	.LVL210:
 2185               	.LBE124:
 2186 039c 8B83      		std Y+3,r24
1610:stk500boot.c  **** 					break;
 2187               		.loc 1 1610 0
 2188 039e 1C82      		std Y+4,__zero_reg__
1611:stk500boot.c  **** 
 2189               		.loc 1 1611 0
 2190 03a0 A12C      		mov r10,__zero_reg__
 2191               	.LVL211:
1607:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 2192               		.loc 1 1607 0
 2193 03a2 84E0      		ldi r24,lo8(4)
 2194 03a4 90E0      		ldi r25,0
 2195               	.LVL212:
1611:stk500boot.c  **** 
 2196               		.loc 1 1611 0
 2197 03a6 00C0      		rjmp .L113
 2198               	.LVL213:
 2199               	.L101:
1421:stk500boot.c  **** 			{
 2200               		.loc 1 1421 0
 2201 03a8 A12C      		mov r10,__zero_reg__
 2202               	.LVL214:
 2203               	.L104:
1581:stk500boot.c  **** 					msgLength		=	2;
 2204               		.loc 1 1581 0
 2205 03aa CC5D      		subi r28,lo8(-292)
 2206 03ac DE4F      		sbci r29,hi8(-292)
 2207 03ae 2881      		ld r18,Y
 2208 03b0 C452      		subi r28,lo8(292)
 2209 03b2 D140      		sbci r29,hi8(292)
 2210 03b4 2223      		tst r18
 2211 03b6 01F4      		brne .+2
 2212 03b8 00C0      		rjmp .L113
 2213               	.LVL215:
1583:stk500boot.c  **** 				}
 2214               		.loc 1 1583 0
 2215 03ba 1A82      		std Y+2,__zero_reg__
 2216               	.LVL216:
 2217               	.L197:
1663:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 2218               		.loc 1 1663 0
 2219 03bc 82E0      		ldi r24,lo8(2)
 2220 03be 90E0      		ldi r25,0
1665:stk500boot.c  **** 
 2221               		.loc 1 1665 0
 2222 03c0 00C0      		rjmp .L113
 2223               	.LVL217:
 2224               	.L110:
1427:stk500boot.c  **** 					{
 2225               		.loc 1 1427 0
 2226 03c2 9E81      		ldd r25,Y+6
 2227 03c4 8091 0000 		lds r24,authenticationToken
 2228               	.LVL218:
 2229 03c8 9813      		cpse r25,r24
 2230 03ca 00C0      		rjmp .L112
1427:stk500boot.c  **** 					{
 2231               		.loc 1 1427 0 is_stmt 0 discriminator 1
 2232 03cc 9F81      		ldd r25,Y+7
 2233 03ce 8091 0000 		lds r24,authenticationToken+1
 2234 03d2 9813      		cpse r25,r24
 2235 03d4 00C0      		rjmp .L112
1427:stk500boot.c  **** 					{
 2236               		.loc 1 1427 0 discriminator 2
 2237 03d6 9885      		ldd r25,Y+8
 2238 03d8 8091 0000 		lds r24,authenticationToken+2
 2239 03dc 9813      		cpse r25,r24
 2240 03de 00C0      		rjmp .L112
1427:stk500boot.c  **** 					{
 2241               		.loc 1 1427 0 discriminator 3
 2242 03e0 9985      		ldd r25,Y+9
 2243 03e2 8091 0000 		lds r24,authenticationToken+3
 2244 03e6 9813      		cpse r25,r24
 2245 03e8 00C0      		rjmp .L112
 2246               	.LBB125:
1429:stk500boot.c  **** 						authenticationNumber.authBytes[1] = msgBuffer[2];
 2247               		.loc 1 1429 0 is_stmt 1
 2248 03ea 8A81      		ldd r24,Y+2
 2249 03ec 8093 0000 		sts authenticationNumber,r24
1430:stk500boot.c  **** 						authenticationNumber.authBytes[2] = msgBuffer[3];
 2250               		.loc 1 1430 0
 2251 03f0 8B81      		ldd r24,Y+3
 2252 03f2 8093 0000 		sts authenticationNumber+1,r24
1431:stk500boot.c  **** 						authenticationNumber.authBytes[3] = msgBuffer[4];
 2253               		.loc 1 1431 0
 2254 03f6 8C81      		ldd r24,Y+4
 2255 03f8 8093 0000 		sts authenticationNumber+2,r24
1432:stk500boot.c  **** 
 2256               		.loc 1 1432 0
 2257 03fc 2D81      		ldd r18,Y+5
 2258 03fe 2093 0000 		sts authenticationNumber+3,r18
 2259               	.LVL219:
1437:stk500boot.c  **** 
 2260               		.loc 1 1437 0
 2261 0402 8091 0000 		lds r24,authenticationNumber
 2262 0406 9091 0000 		lds r25,authenticationNumber+1
 2263 040a A091 0000 		lds r26,authenticationNumber+2
 2264 040e B091 0000 		lds r27,authenticationNumber+3
 2265 0412 820F      		add r24,r18
 2266 0414 911D      		adc r25,__zero_reg__
 2267 0416 A11D      		adc r26,__zero_reg__
 2268 0418 B11D      		adc r27,__zero_reg__
 2269 041a 8093 0000 		sts authenticationNumber,r24
 2270 041e 9093 0000 		sts authenticationNumber+1,r25
 2271 0422 A093 0000 		sts authenticationNumber+2,r26
 2272 0426 B093 0000 		sts authenticationNumber+3,r27
1439:stk500boot.c  **** 						msgBuffer[1] = authenticationNumber.authBytes[0];
 2273               		.loc 1 1439 0
 2274 042a 1982      		std Y+1,__zero_reg__
1440:stk500boot.c  **** 						msgBuffer[2] = authenticationNumber.authBytes[1];
 2275               		.loc 1 1440 0
 2276 042c 8A83      		std Y+2,r24
1441:stk500boot.c  **** 						msgBuffer[3] = authenticationNumber.authBytes[2];
 2277               		.loc 1 1441 0
 2278 042e 9B83      		std Y+3,r25
1442:stk500boot.c  **** 						msgBuffer[4] = authenticationNumber.authBytes[3];
 2279               		.loc 1 1442 0
 2280 0430 AC83      		std Y+4,r26
1443:stk500boot.c  **** 
 2281               		.loc 1 1443 0
 2282 0432 BD83      		std Y+5,r27
 2283               	.LVL220:
 2284               	.LBE125:
1428:stk500boot.c  **** 						authenticationNumber.authBytes[0] = msgBuffer[1];
 2285               		.loc 1 1428 0
 2286 0434 A12C      		mov r10,__zero_reg__
 2287               	.LVL221:
 2288               	.LBB126:
1446:stk500boot.c  **** 
 2289               		.loc 1 1446 0
 2290 0436 E1E0      		ldi r30,lo8(1)
 2291               	.LVL222:
 2292 0438 CC5D      		subi r28,lo8(-292)
 2293 043a DE4F      		sbci r29,hi8(-292)
 2294 043c E883      		st Y,r30
 2295 043e C452      		subi r28,lo8(292)
 2296 0440 D140      		sbci r29,hi8(292)
1445:stk500boot.c  **** 						isAuthenticated = 0x01;
 2297               		.loc 1 1445 0
 2298 0442 85E0      		ldi r24,lo8(5)
 2299 0444 90E0      		ldi r25,0
 2300               	.LVL223:
 2301               	.L113:
 2302               	.LBE126:
1772:stk500boot.c  **** 					break;
1773:stk500boot.c  **** 			}
1774:stk500boot.c  **** 
1775:stk500boot.c  **** 			/*
1776:stk500boot.c  **** 			 * Now send answer message back
1777:stk500boot.c  **** 			 */
1778:stk500boot.c  **** 
1779:stk500boot.c  **** 			 // encryption kismi burada olmali
1780:stk500boot.c  **** 
1781:stk500boot.c  **** // aes_encrypt(receivedPacket, aes_buffer, packetSize);
1782:stk500boot.c  **** 			receivedPacketIndex = 0;
1783:stk500boot.c  **** 
1784:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = MESSAGE_START;
 2303               		.loc 1 1784 0
 2304 0446 2BE1      		ldi r18,lo8(27)
 2305 0448 2093 0000 		sts receivedPacket,r18
 2306               	.LVL224:
1785:stk500boot.c  **** 
1786:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1787:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = seqNum;
 2307               		.loc 1 1787 0
 2308 044c CB5D      		subi r28,lo8(-293)
 2309 044e DE4F      		sbci r29,hi8(-293)
 2310 0450 A881      		ld r26,Y
 2311 0452 C552      		subi r28,lo8(293)
 2312 0454 D140      		sbci r29,hi8(293)
 2313 0456 A093 0000 		sts receivedPacket+1,r26
 2314               	.LVL225:
1788:stk500boot.c  **** 			checksum	^=	seqNum;
1789:stk500boot.c  **** 
1790:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
 2315               		.loc 1 1790 0
 2316 045a 692F      		mov r22,r25
 2317               	.LVL226:
1791:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = c;
 2318               		.loc 1 1791 0
 2319 045c 9093 0000 		sts receivedPacket+2,r25
 2320               	.LVL227:
1792:stk500boot.c  **** 			checksum	^=	c;
1793:stk500boot.c  **** 
1794:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1795:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = c;
 2321               		.loc 1 1795 0
 2322 0460 8093 0000 		sts receivedPacket+3,r24
 2323 0464 55E1      		ldi r21,lo8(21)
 2324 0466 B52E      		mov r11,r21
 2325 0468 BA26      		eor r11,r26
 2326 046a B826      		eor r11,r24
 2327               	.LVL228:
1796:stk500boot.c  **** 			checksum ^= c;
1797:stk500boot.c  **** 			residualNumber = (msgLength+6) % 16;
 2328               		.loc 1 1797 0
 2329 046c FC01      		movw r30,r24
 2330 046e 3696      		adiw r30,6
 2331 0470 AF01      		movw r20,r30
 2332 0472 4F70      		andi r20,15
 2333 0474 5527      		clr r21
 2334               	.LVL229:
1798:stk500boot.c  **** 
1799:stk500boot.c  **** 			finalResponseSize = ((msgLength+(16-residualNumber)+6));
 2335               		.loc 1 1799 0
 2336 0476 6C01      		movw r12,r24
 2337 0478 B6E1      		ldi r27,22
 2338 047a CB0E      		add r12,r27
 2339 047c D11C      		adc r13,__zero_reg__
 2340 047e C41A      		sub r12,r20
 2341 0480 D50A      		sbc r13,r21
 2342               	.LVL230:
1800:stk500boot.c  **** 
1801:stk500boot.c  **** 			if(residualNumber != 0)
 2343               		.loc 1 1801 0
 2344 0482 452B      		or r20,r21
 2345 0484 01F0      		breq .+2
 2346 0486 00C0      		rjmp .L133
 2347               	.LVL231:
 2348               	.L137:
1802:stk500boot.c  **** 			{
1803:stk500boot.c  **** 
1804:stk500boot.c  **** 				for(int excessiveNumberIndex = (msgLength+6); excessiveNumberIndex<finalResponseSize; excessive
1805:stk500boot.c  **** 				{
1806:stk500boot.c  **** 
1807:stk500boot.c  **** 					receivedPacket[excessiveNumberIndex] = 0xff;
1808:stk500boot.c  **** 				}
1809:stk500boot.c  **** 
1810:stk500boot.c  **** 			}
1811:stk500boot.c  **** 
1812:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = TOKEN;
 2349               		.loc 1 1812 0
 2350 0488 2EE0      		ldi r18,lo8(14)
 2351 048a 2093 0000 		sts receivedPacket+4,r18
1813:stk500boot.c  **** 			checksum ^= TOKEN;
 2352               		.loc 1 1813 0
 2353 048e B626      		eor r11,r22
 2354               	.LVL232:
 2355 0490 FE01      		movw r30,r28
 2356 0492 3196      		adiw r30,1
 2357 0494 A0E0      		ldi r26,lo8(receivedPacket+5)
 2358 0496 B0E0      		ldi r27,hi8(receivedPacket+5)
 2359 0498 9C01      		movw r18,r24
 2360 049a 2E0F      		add r18,r30
 2361 049c 3F1F      		adc r19,r31
 2362               	.LVL233:
 2363               	.L134:
1814:stk500boot.c  **** 			p	=	msgBuffer;
1815:stk500boot.c  **** 			while ( msgLength )
 2364               		.loc 1 1815 0
 2365 049e 2E17      		cp r18,r30
 2366 04a0 3F07      		cpc r19,r31
 2367 04a2 01F0      		breq .+2
 2368 04a4 00C0      		rjmp .L138
 2369               	.LVL234:
1816:stk500boot.c  **** 			{
1817:stk500boot.c  **** 				c	=	*p++;
1818:stk500boot.c  **** 				receivedPacket[receivedPacketIndex++] = c;
1819:stk500boot.c  **** 				checksum ^=c;
1820:stk500boot.c  **** 				msgLength--;
1821:stk500boot.c  **** 			}
1822:stk500boot.c  **** 
1823:stk500boot.c  **** 			receivedPacket[receivedPacketIndex++] = checksum;
 2370               		.loc 1 1823 0
 2371 04a6 8050      		subi r24,lo8(-(receivedPacket))
 2372 04a8 9040      		sbci r25,hi8(-(receivedPacket))
 2373               	.LVL235:
 2374 04aa FC01      		movw r30,r24
 2375               	.LVL236:
 2376 04ac B582      		std Z+5,r11
1824:stk500boot.c  **** 			seqNum++;
 2377               		.loc 1 1824 0
 2378 04ae CB5D      		subi r28,lo8(-293)
 2379 04b0 DE4F      		sbci r29,hi8(-293)
 2380 04b2 F881      		ld r31,Y
 2381 04b4 C552      		subi r28,lo8(293)
 2382 04b6 D140      		sbci r29,hi8(293)
 2383 04b8 FF5F      		subi r31,lo8(-(1))
 2384 04ba CB5D      		subi r28,lo8(-293)
 2385 04bc DE4F      		sbci r29,hi8(-293)
 2386 04be F883      		st Y,r31
 2387 04c0 C552      		subi r28,lo8(293)
 2388 04c2 D140      		sbci r29,hi8(293)
 2389               	.LVL237:
 2390               	.LBB127:
 2391               	.LBB128:
 917:stk500boot.c  **** 
 2392               		.loc 1 917 0
 2393 04c4 2C2D      		mov r18,r12
 2394 04c6 2F70      		andi r18,lo8(15)
 2395 04c8 C95D      		subi r28,lo8(-295)
 2396 04ca DE4F      		sbci r29,hi8(-295)
 2397 04cc 2883      		st Y,r18
 2398 04ce C752      		subi r28,lo8(295)
 2399 04d0 D140      		sbci r29,hi8(295)
 2400               	.LVL238:
 922:stk500boot.c  ****     KeyExpansion();
 2401               		.loc 1 922 0
 2402 04d2 80E0      		ldi r24,lo8(key)
 2403 04d4 90E0      		ldi r25,hi8(key)
 2404               	.LVL239:
 2405 04d6 9093 0000 		sts Key+1,r25
 2406 04da 8093 0000 		sts Key,r24
 923:stk500boot.c  ****   }
 2407               		.loc 1 923 0
 2408 04de 0E94 0000 		call KeyExpansion
 2409               	.LVL240:
 928:stk500boot.c  ****   }
 2410               		.loc 1 928 0
 2411 04e2 A0E0      		ldi r26,lo8(iv)
 2412 04e4 B0E0      		ldi r27,hi8(iv)
 2413 04e6 B093 0000 		sts Iv+1,r27
 2414 04ea A093 0000 		sts Iv,r26
 2415               	.LVL241:
 2416 04ee 40E0      		ldi r20,lo8(receivedPacket)
 2417 04f0 E42E      		mov r14,r20
 2418 04f2 40E0      		ldi r20,hi8(receivedPacket)
 2419 04f4 F42E      		mov r15,r20
 2420 04f6 00E0      		ldi r16,lo8(aes_buffer)
 2421 04f8 10E0      		ldi r17,hi8(aes_buffer)
 2422               	.LVL242:
 2423               	.L139:
 931:stk500boot.c  ****   {
 2424               		.loc 1 931 0
 2425 04fa C701      		movw r24,r14
 2426 04fc 8050      		subi r24,lo8(receivedPacket)
 2427 04fe 9040      		sbci r25,hi8(receivedPacket)
 2428               	.LVL243:
 2429 0500 8C15      		cp r24,r12
 2430 0502 9D05      		cpc r25,r13
 2431 0504 00F4      		brsh .+2
 2432 0506 00C0      		rjmp .L140
 943:stk500boot.c  ****   {
 2433               		.loc 1 943 0
 2434 0508 C95D      		subi r28,lo8(-295)
 2435 050a DE4F      		sbci r29,hi8(-295)
 2436 050c E881      		ld r30,Y
 2437 050e C752      		subi r28,lo8(295)
 2438 0510 D140      		sbci r29,hi8(295)
 2439 0512 EE23      		tst r30
 2440 0514 01F0      		breq .L141
 945:stk500boot.c  ****     state = (state_t*)output;
 2441               		.loc 1 945 0
 2442 0516 4E2F      		mov r20,r30
 2443 0518 50E0      		ldi r21,0
 2444 051a B701      		movw r22,r14
 2445 051c C801      		movw r24,r16
 2446               	.LVL244:
 2447 051e 0E94 0000 		call memcpy
 2448               	.LVL245:
 946:stk500boot.c  ****     Cipher();
 2449               		.loc 1 946 0
 2450 0522 1093 0000 		sts state+1,r17
 2451 0526 0093 0000 		sts state,r16
 947:stk500boot.c  ****   }
 2452               		.loc 1 947 0
 2453 052a 0E94 0000 		call Cipher
 2454               	.LVL246:
 2455               	.L141:
 2456               	.LBE128:
 2457               	.LBE127:
1825:stk500boot.c  **** 
1826:stk500boot.c  **** 
1827:stk500boot.c  **** 
1828:stk500boot.c  **** 
1829:stk500boot.c  **** 
1830:stk500boot.c  **** 
1831:stk500boot.c  **** 
1832:stk500boot.c  **** 			aes_encrypt(aes_buffer, receivedPacket, finalResponseSize);
1833:stk500boot.c  **** 			sendchar(0x58);
 2458               		.loc 1 1833 0
 2459 052e 88E5      		ldi r24,lo8(88)
 2460 0530 0E94 0000 		call sendchar
 2461               	.LVL247:
1834:stk500boot.c  **** 			sendchar((finalResponseSize>>8)&0xFF);
 2462               		.loc 1 1834 0
 2463 0534 8D2D      		mov r24,r13
 2464 0536 0E94 0000 		call sendchar
 2465               	.LVL248:
1835:stk500boot.c  **** 			sendchar(finalResponseSize&0x00FF);
 2466               		.loc 1 1835 0
 2467 053a 8C2D      		mov r24,r12
 2468 053c 0E94 0000 		call sendchar
 2469               	.LVL249:
 2470               	.LBB130:
1836:stk500boot.c  **** 			for(int i =0; i<finalResponseSize; i++)
 2471               		.loc 1 1836 0
 2472 0540 00E0      		ldi r16,lo8(aes_buffer)
 2473 0542 10E0      		ldi r17,hi8(aes_buffer)
 2474               	.LVL250:
 2475               	.L142:
 2476               		.loc 1 1836 0 is_stmt 0 discriminator 1
 2477 0544 C801      		movw r24,r16
 2478 0546 8050      		subi r24,lo8(aes_buffer)
 2479 0548 9040      		sbci r25,hi8(aes_buffer)
 2480               	.LVL251:
 2481 054a 8C15      		cp r24,r12
 2482 054c 9D05      		cpc r25,r13
 2483 054e 00F4      		brsh .+2
 2484 0550 00C0      		rjmp .L143
 2485               	.LVL252:
 2486               	.LBE130:
1258:stk500boot.c  **** 		{
 2487               		.loc 1 1258 0 is_stmt 1
 2488 0552 AA20      		tst r10
 2489 0554 01F4      		brne .+2
 2490 0556 00C0      		rjmp .L71
 2491               	.LVL253:
 2492               	.L72:
1837:stk500boot.c  **** 			sendchar(aes_buffer[i]);
1838:stk500boot.c  **** 			// sendchar(0x58);
1839:stk500boot.c  **** 			// sendchar((finalResponseSize>>8)&0xFF);
1840:stk500boot.c  **** 			// sendchar(finalResponseSize&0x00FF);
1841:stk500boot.c  **** 			// for(int i =0; i<finalResponseSize; i++)
1842:stk500boot.c  **** 			// sendchar(aes_buffer[i]);
1843:stk500boot.c  **** 
1844:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1845:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1846:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1847:stk500boot.c  **** 		#endif
1848:stk500boot.c  **** 
1849:stk500boot.c  **** 		}
1850:stk500boot.c  **** 	}
1851:stk500boot.c  **** 
1852:stk500boot.c  **** 
1853:stk500boot.c  **** 
1854:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1855:stk500boot.c  **** 	//*	this is for debugging it can be removed
1856:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1857:stk500boot.c  **** 	{
1858:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1859:stk500boot.c  **** 		delay_ms(200);
1860:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1861:stk500boot.c  **** 		delay_ms(200);
1862:stk500boot.c  **** 	}
1863:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1864:stk500boot.c  **** #endif
1865:stk500boot.c  **** 
1866:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1867:stk500boot.c  **** 	sendchar('j');
1868:stk500boot.c  **** //	sendchar('u');
1869:stk500boot.c  **** //	sendchar('m');
1870:stk500boot.c  **** //	sendchar('p');
1871:stk500boot.c  **** //	sendchar(' ');
1872:stk500boot.c  **** //	sendchar('u');
1873:stk500boot.c  **** //	sendchar('s');
1874:stk500boot.c  **** //	sendchar('r');
1875:stk500boot.c  **** 	sendchar(0x0d);
1876:stk500boot.c  **** 	sendchar(0x0a);
1877:stk500boot.c  **** 
1878:stk500boot.c  **** 	delay_ms(100);
1879:stk500boot.c  **** #endif
1880:stk500boot.c  **** 
1881:stk500boot.c  **** 
1882:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1883:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1884:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1885:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1886:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1887:stk500boot.c  **** #endif
1888:stk500boot.c  **** 
1889:stk500boot.c  **** 
1890:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 2493               		.loc 1 1890 0
 2494               	/* #APP */
 2495               	 ;  1890 "stk500boot.c" 1
 2496 0558 0000      		nop
 2497               	 ;  0 "" 2
1891:stk500boot.c  **** 
1892:stk500boot.c  **** 	/*
1893:stk500boot.c  **** 	 * Now leave bootloader
1894:stk500boot.c  **** 	 */
1895:stk500boot.c  **** 
1896:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 2498               		.loc 1 1896 0
 2499               	/* #NOAPP */
 2500 055a 8091 C000 		lds r24,192
 2501 055e 8D7F      		andi r24,lo8(-3)
 2502 0560 8093 C000 		sts 192,r24
1897:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 2503               		.loc 1 1897 0
 2504 0564 81E1      		ldi r24,lo8(17)
 2505               	/* #APP */
 2506               	 ;  1897 "stk500boot.c" 1
 2507 0566 8093 5700 		sts 87, r24
 2508 056a E895      		spm
 2509               		
 2510               	 ;  0 "" 2
1898:stk500boot.c  **** 
1899:stk500boot.c  **** 
1900:stk500boot.c  **** 	asm volatile(
 2511               		.loc 1 1900 0
 2512               	 ;  1900 "stk500boot.c" 1
 2513 056c EE27      		clr	r30		
 2514 056e FF27      		clr	r31		
 2515 0570 0994      		ijmp	
 2516               		
 2517               	 ;  0 "" 2
 2518               	/* #NOAPP */
 2519               	.L144:
 2520 0572 00C0      		rjmp .L144
 2521               	.LVL254:
 2522               	.L112:
1451:stk500boot.c  **** 							msgLength = 1;
 2523               		.loc 1 1451 0
 2524 0574 80EC      		ldi r24,lo8(-64)
 2525 0576 8983      		std Y+1,r24
 2526               	.LVL255:
1452:stk500boot.c  **** 							isAuthenticated = 0x00;
 2527               		.loc 1 1452 0
 2528 0578 81E0      		ldi r24,lo8(1)
 2529 057a 90E0      		ldi r25,0
1451:stk500boot.c  **** 							msgLength = 1;
 2530               		.loc 1 1451 0
 2531 057c A12C      		mov r10,__zero_reg__
 2532               	.LVL256:
1453:stk500boot.c  **** 					}
 2533               		.loc 1 1453 0
 2534 057e CC5D      		subi r28,lo8(-292)
 2535 0580 DE4F      		sbci r29,hi8(-292)
 2536 0582 1882      		st Y,__zero_reg__
 2537 0584 C452      		subi r28,lo8(292)
 2538 0586 D140      		sbci r29,hi8(292)
 2539 0588 00C0      		rjmp .L113
 2540               	.LVL257:
 2541               	.L114:
1538:stk500boot.c  **** 					msgLength		=	1;
 2542               		.loc 1 1538 0
 2543 058a 80EC      		ldi r24,lo8(-64)
 2544               	.LVL258:
 2545 058c 8A83      		std Y+2,r24
 2546               	.LVL259:
 2547 058e A12C      		mov r10,__zero_reg__
 2548               	.LVL260:
1539:stk500boot.c  **** 				}
 2549               		.loc 1 1539 0
 2550 0590 81E0      		ldi r24,lo8(1)
 2551 0592 90E0      		ldi r25,0
 2552 0594 00C0      		rjmp .L113
 2553               	.LVL261:
 2554               	.L102:
 2555 0596 EA81      		ldd r30,Y+2
 2556               	.LVL262:
 2557 0598 E059      		subi r30,lo8(-(112))
 2558               	.LBB131:
1548:stk500boot.c  **** 						{
 2559               		.loc 1 1548 0
 2560 059a 80E0      		ldi r24,0
 2561               	.LVL263:
 2562 059c E330      		cpi r30,lo8(3)
 2563 059e 00F4      		brsh .L115
 2564 05a0 F0E0      		ldi r31,0
 2565 05a2 E050      		subi r30,lo8(-(CSWTCH.140))
 2566 05a4 F040      		sbci r31,hi8(-(CSWTCH.140))
 2567 05a6 8081      		ld r24,Z
 2568               	.L115:
 2569               	.LVL264:
1570:stk500boot.c  **** 						msgBuffer[2]	=	value;
 2570               		.loc 1 1570 0
 2571 05a8 1A82      		std Y+2,__zero_reg__
1571:stk500boot.c  **** 					}
 2572               		.loc 1 1571 0
 2573 05aa 8B83      		std Y+3,r24
 2574               	.LBE131:
1573:stk500boot.c  **** 
 2575               		.loc 1 1573 0
 2576 05ac A12C      		mov r10,__zero_reg__
 2577               	.LVL265:
 2578               	.LBB132:
1569:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 2579               		.loc 1 1569 0
 2580 05ae 83E0      		ldi r24,lo8(3)
 2581 05b0 90E0      		ldi r25,0
 2582               	.LVL266:
 2583               	.LBE132:
1573:stk500boot.c  **** 
 2584               		.loc 1 1573 0
 2585 05b2 00C0      		rjmp .L113
 2586               	.LVL267:
 2587               	.L150:
1576:stk500boot.c  **** 					//*	fall thru
 2588               		.loc 1 1576 0
 2589 05b4 AA24      		clr r10
 2590 05b6 A394      		inc r10
 2591               	.LVL268:
 2592 05b8 00C0      		rjmp .L104
 2593               	.LVL269:
 2594               	.L109:
 2595               	.LBB133:
1589:stk500boot.c  **** 						unsigned char signature;
 2596               		.loc 1 1589 0
 2597 05ba 8D81      		ldd r24,Y+5
 2598               	.LVL270:
1592:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 2599               		.loc 1 1592 0
 2600 05bc 8823      		tst r24
 2601 05be 01F0      		breq .L152
1594:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 2602               		.loc 1 1594 0
 2603 05c0 8130      		cpi r24,lo8(1)
 2604 05c2 01F4      		brne .L153
1595:stk500boot.c  **** 						else
 2605               		.loc 1 1595 0
 2606 05c4 88E9      		ldi r24,lo8(-104)
 2607               	.LVL271:
 2608               	.L200:
 2609               	.LBE133:
 2610               	.LBB134:
1629:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 2611               		.loc 1 1629 0
 2612 05c6 1A82      		std Y+2,__zero_reg__
 2613 05c8 00C0      		rjmp .L199
 2614               	.LVL272:
 2615               	.L152:
 2616               	.LBE134:
 2617               	.LBB139:
1593:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 2618               		.loc 1 1593 0
 2619 05ca 8EE1      		ldi r24,lo8(30)
 2620               	.LVL273:
 2621 05cc 00C0      		rjmp .L200
 2622               	.LVL274:
 2623               	.L153:
1597:stk500boot.c  **** 
 2624               		.loc 1 1597 0
 2625 05ce 81E0      		ldi r24,lo8(1)
 2626               	.LVL275:
 2627 05d0 00C0      		rjmp .L200
 2628               	.LVL276:
 2629               	.L106:
 2630               	.LBE139:
 2631               	.LBB140:
1617:stk500boot.c  **** 						{
 2632               		.loc 1 1617 0
 2633 05d2 8B81      		ldd r24,Y+3
 2634               	.LVL277:
 2635 05d4 8035      		cpi r24,lo8(80)
 2636 05d6 01F4      		brne .L117
1619:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 2637               		.loc 1 1619 0
 2638 05d8 8C81      		ldd r24,Y+4
 2639 05da 8830      		cpi r24,lo8(8)
 2640 05dc 01F4      		brne .L118
 2641               	.LBB135:
1620:stk500boot.c  **** 							else
 2642               		.loc 1 1620 0
 2643 05de 89E0      		ldi r24,lo8(9)
 2644 05e0 E2E0      		ldi r30,lo8(2)
 2645 05e2 F0E0      		ldi r31,0
 2646               	.LVL278:
 2647               	.L196:
 2648               	.LBE135:
 2649               	.LBB136:
1626:stk500boot.c  **** 						}
 2650               		.loc 1 1626 0
 2651               	/* #APP */
 2652               	 ;  1626 "stk500boot.c" 1
 2653 05e4 8093 5700 		sts 87, r24
 2654 05e8 8491      		lpm r24, Z
 2655               		
 2656               	 ;  0 "" 2
 2657               	.LVL279:
 2658               	/* #NOAPP */
 2659 05ea 00C0      		rjmp .L200
 2660               	.LVL280:
 2661               	.L118:
 2662               	.LBE136:
 2663               	.LBB137:
1622:stk500boot.c  **** 						}
 2664               		.loc 1 1622 0
 2665 05ec 89E0      		ldi r24,lo8(9)
 2666 05ee F0E0      		ldi r31,0
 2667 05f0 E0E0      		ldi r30,0
 2668               	.LVL281:
 2669 05f2 00C0      		rjmp .L196
 2670               	.LVL282:
 2671               	.L117:
 2672               	.LBE137:
 2673               	.LBB138:
1626:stk500boot.c  **** 						}
 2674               		.loc 1 1626 0
 2675 05f4 89E0      		ldi r24,lo8(9)
 2676 05f6 E3E0      		ldi r30,lo8(3)
 2677 05f8 F0E0      		ldi r31,0
 2678               	.LVL283:
 2679 05fa 00C0      		rjmp .L196
 2680               	.LVL284:
 2681               	.L105:
 2682               	.LBE138:
 2683               	.LBE140:
1654:stk500boot.c  **** 					break;
 2684               		.loc 1 1654 0
 2685 05fc 80EC      		ldi r24,lo8(-64)
 2686 05fe 8A83      		std Y+2,r24
1655:stk500boot.c  **** 
 2687               		.loc 1 1655 0
 2688 0600 A12C      		mov r10,__zero_reg__
 2689               	.LVL285:
1652:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 2690               		.loc 1 1652 0
 2691 0602 82E0      		ldi r24,lo8(2)
 2692 0604 90E0      		ldi r25,0
1651:stk500boot.c  **** 					msgLength		=	2;
 2693               		.loc 1 1651 0
 2694 0606 C05E      		subi r28,lo8(-288)
 2695 0608 DE4F      		sbci r29,hi8(-288)
 2696 060a 1882      		st Y,__zero_reg__
 2697 060c 1982      		std Y+1,__zero_reg__
 2698 060e 1A82      		std Y+2,__zero_reg__
 2699 0610 1B82      		std Y+3,__zero_reg__
 2700 0612 C052      		subi r28,lo8(288)
 2701 0614 D140      		sbci r29,hi8(288)
1655:stk500boot.c  **** 
 2702               		.loc 1 1655 0
 2703 0616 00C0      		rjmp .L113
 2704               	.LVL286:
 2705               	.L99:
 2706 0618 6A81      		ldd r22,Y+2
 2707 061a 7B81      		ldd r23,Y+3
 2708 061c 8C81      		ldd r24,Y+4
 2709 061e 9D81      		ldd r25,Y+5
 2710 0620 0E94 0000 		call __bswapsi2
1659:stk500boot.c  **** 	#else
 2711               		.loc 1 1659 0
 2712 0624 2B01      		movw r4,r22
 2713 0626 3C01      		movw r6,r24
 2714 0628 440C      		lsl r4
 2715 062a 551C      		rol r5
 2716 062c 661C      		rol r6
 2717 062e 771C      		rol r7
 2718               	.LVL287:
1664:stk500boot.c  **** 					break;
 2719               		.loc 1 1664 0
 2720 0630 1A82      		std Y+2,__zero_reg__
 2721               	.LVL288:
 2722               	.L198:
1665:stk500boot.c  **** 
 2723               		.loc 1 1665 0
 2724 0632 A12C      		mov r10,__zero_reg__
 2725 0634 00C0      		rjmp .L197
 2726               	.LVL289:
 2727               	.L97:
1670:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2]; // ok
 2728               		.loc 1 1670 0
 2729 0636 CC5D      		subi r28,lo8(-292)
 2730 0638 DE4F      		sbci r29,hi8(-292)
 2731 063a F881      		ld r31,Y
 2732 063c C452      		subi r28,lo8(292)
 2733 063e D140      		sbci r29,hi8(292)
 2734 0640 FF23      		tst r31
 2735 0642 01F4      		brne .+2
 2736 0644 00C0      		rjmp .L154
 2737 0646 0A81      		ldd r16,Y+2
 2738 0648 1B81      		ldd r17,Y+3
 2739               	.LVL290:
 2740 064a 1027      		eor r17,r16
 2741 064c 0127      		eor r16,r17
 2742 064e 1027      		eor r17,r16
 2743               	.LVL291:
 2744               	.LBB141:
1679:stk500boot.c  **** 						{
 2745               		.loc 1 1679 0
 2746 0650 4331      		cpi r20,lo8(19)
 2747 0652 01F0      		breq .+2
 2748 0654 00C0      		rjmp .L120
1682:stk500boot.c  **** 							{
 2749               		.loc 1 1682 0
 2750 0656 C05E      		subi r28,lo8(-288)
 2751 0658 DE4F      		sbci r29,hi8(-288)
 2752 065a 8881      		ld r24,Y
 2753 065c 9981      		ldd r25,Y+1
 2754 065e AA81      		ldd r26,Y+2
 2755 0660 BB81      		ldd r27,Y+3
 2756 0662 C052      		subi r28,lo8(288)
 2757 0664 D140      		sbci r29,hi8(288)
 2758               	.LVL292:
 2759 0666 8115      		cp r24,__zero_reg__
 2760 0668 E0EC      		ldi r30,-64
 2761 066a 9E07      		cpc r25,r30
 2762 066c E3E0      		ldi r30,3
 2763 066e AE07      		cpc r26,r30
 2764 0670 B105      		cpc r27,__zero_reg__
 2765               	.LVL293:
 2766 0672 00F4      		brsh .L121
1684:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 2767               		.loc 1 1684 0
 2768 0674 23E0      		ldi r18,lo8(3)
 2769               	/* #APP */
 2770               	 ;  1684 "stk500boot.c" 1
 2771 0676 FC01      		movw r30, r24
 2772 0678 A093 5B00 		sts  91, r26
 2773 067c 2093 5700 		sts 87, r18
 2774 0680 E895      		spm
 2775               		
 2776               	 ;  0 "" 2
 2777               	/* #NOAPP */
 2778               	.L122:
1685:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 2779               		.loc 1 1685 0 discriminator 1
 2780 0682 07B6      		in __tmp_reg__,0x37
 2781 0684 00FC      		sbrc __tmp_reg__,0
 2782 0686 00C0      		rjmp .L122
1686:stk500boot.c  **** 							}
 2783               		.loc 1 1686 0
 2784 0688 C05E      		subi r28,lo8(-288)
 2785 068a DE4F      		sbci r29,hi8(-288)
 2786 068c 8881      		ld r24,Y
 2787 068e 9981      		ldd r25,Y+1
 2788 0690 AA81      		ldd r26,Y+2
 2789 0692 BB81      		ldd r27,Y+3
 2790 0694 C052      		subi r28,lo8(288)
 2791 0696 D140      		sbci r29,hi8(288)
 2792 0698 9F5F      		subi r25,-1
 2793 069a AF4F      		sbci r26,-1
 2794 069c BF4F      		sbci r27,-1
 2795 069e C05E      		subi r28,lo8(-288)
 2796 06a0 DE4F      		sbci r29,hi8(-288)
 2797 06a2 8883      		st Y,r24
 2798 06a4 9983      		std Y+1,r25
 2799 06a6 AA83      		std Y+2,r26
 2800 06a8 BB83      		std Y+3,r27
 2801 06aa C052      		subi r28,lo8(288)
 2802 06ac D140      		sbci r29,hi8(288)
 2803               	.LVL294:
 2804               	.L121:
 2805 06ae 8B85      		ldd r24,Y+11
 2806 06b0 DE01      		movw r26,r28
 2807 06b2 1196      		adiw r26,1
 2808               	.LBE141:
 2809               	.LBB143:
1597:stk500boot.c  **** 
 2810               		.loc 1 1597 0 discriminator 1
 2811 06b4 B301      		movw r22,r6
 2812 06b6 A201      		movw r20,r4
 2813               	.L124:
 2814               	.LVL295:
 2815               	.LBE143:
 2816               	.LBB144:
1695:stk500boot.c  **** 								boot_page_fill(address,data);
 2817               		.loc 1 1695 0 discriminator 1
 2818 06b8 1B96      		adiw r26,11
 2819 06ba 9C91      		ld r25,X
 2820 06bc 1B97      		sbiw r26,11
1696:stk500boot.c  **** 
 2821               		.loc 1 1696 0 discriminator 1
 2822 06be 21E0      		ldi r18,lo8(1)
 2823               	/* #APP */
 2824               	 ;  1696 "stk500boot.c" 1
 2825 06c0 0C01      		movw  r0, r24
 2826 06c2 FA01      		movw r30, r20
 2827 06c4 6093 5B00 		sts 91, r22
 2828 06c8 2093 5700 		sts 87, r18
 2829 06cc E895      		spm
 2830 06ce 1124      		clr  r1
 2831               		
 2832               	 ;  0 "" 2
1698:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 2833               		.loc 1 1698 0 discriminator 1
 2834               	/* #NOAPP */
 2835 06d0 4E5F      		subi r20,-2
 2836 06d2 5F4F      		sbci r21,-1
 2837 06d4 6F4F      		sbci r22,-1
 2838 06d6 7F4F      		sbci r23,-1
 2839               	.LVL296:
1699:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 2840               		.loc 1 1699 0 discriminator 1
 2841 06d8 0250      		subi r16,2
 2842 06da 1109      		sbc r17,__zero_reg__
 2843               	.LVL297:
 2844 06dc 1296      		adiw r26,2
 2845               	.LVL298:
1700:stk500boot.c  **** 
 2846               		.loc 1 1700 0 discriminator 1
 2847 06de 0115      		cp r16,__zero_reg__
 2848 06e0 1105      		cpc r17,__zero_reg__
 2849 06e2 01F0      		breq .L123
1693:stk500boot.c  **** 
 2850               		.loc 1 1693 0
 2851 06e4 1A96      		adiw r26,10
 2852 06e6 8C91      		ld r24,X
 2853 06e8 1A97      		sbiw r26,10
 2854               	.LVL299:
 2855 06ea 00C0      		rjmp .L124
 2856               	.LVL300:
 2857               	.L123:
1702:stk500boot.c  **** 							boot_spm_busy_wait();
 2858               		.loc 1 1702 0
 2859 06ec 85E0      		ldi r24,lo8(5)
 2860               	.LVL301:
 2861               	/* #APP */
 2862               	 ;  1702 "stk500boot.c" 1
 2863 06ee F201      		movw r30, r4
 2864 06f0 6092 5B00 		sts 91, r6
 2865 06f4 8093 5700 		sts 87, r24
 2866 06f8 E895      		spm
 2867               		
 2868               	 ;  0 "" 2
 2869               	/* #NOAPP */
 2870               	.L125:
1703:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 2871               		.loc 1 1703 0 discriminator 1
 2872 06fa 07B6      		in __tmp_reg__,0x37
 2873 06fc 00FC      		sbrc __tmp_reg__,0
 2874 06fe 00C0      		rjmp .L125
1704:stk500boot.c  **** 						}
 2875               		.loc 1 1704 0
 2876 0700 81E1      		ldi r24,lo8(17)
 2877               	/* #APP */
 2878               	 ;  1704 "stk500boot.c" 1
 2879 0702 8093 5700 		sts 87, r24
 2880 0706 E895      		spm
 2881               		
 2882               	 ;  0 "" 2
 2883               	.LVL302:
 2884               	/* #NOAPP */
 2885               	.L126:
1719:stk500boot.c  **** 					}
 2886               		.loc 1 1719 0
 2887 0708 1A82      		std Y+2,__zero_reg__
 2888 070a 2A01      		movw r4,r20
 2889               	.LVL303:
 2890 070c 3B01      		movw r6,r22
 2891 070e 00C0      		rjmp .L198
 2892               	.LVL304:
 2893               	.L120:
 2894               	.LBB142:
1709:stk500boot.c  **** 							/* write EEPROM */
 2895               		.loc 1 1709 0
 2896 0710 7301      		movw r14,r6
 2897               	.LVL305:
 2898 0712 6201      		movw r12,r4
 2899               	.LVL306:
 2900 0714 F694      		lsr r15
 2901 0716 E794      		ror r14
 2902 0718 D794      		ror r13
 2903 071a C794      		ror r12
 2904               	.LVL307:
 2905 071c 5101      		movw r10,r2
 2906               	.LVL308:
 2907 071e A00E      		add r10,r16
 2908 0720 B11E      		adc r11,r17
1711:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 2909               		.loc 1 1711 0
 2910 0722 7101      		movw r14,r2
1712:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 2911               		.loc 1 1712 0
 2912 0724 C218      		sub r12,r2
 2913 0726 D308      		sbc r13,r3
 2914               	.LVL309:
 2915               	.L127:
1711:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 2916               		.loc 1 1711 0
 2917 0728 AE14      		cp r10,r14
 2918 072a BF04      		cpc r11,r15
 2919 072c 01F4      		brne .L128
 2920 072e 30E0      		ldi r19,0
 2921 0730 20E0      		ldi r18,0
 2922 0732 000F      		lsl r16
 2923 0734 111F      		rol r17
 2924 0736 221F      		rol r18
 2925 0738 331F      		rol r19
 2926 073a B901      		movw r22,r18
 2927 073c A801      		movw r20,r16
 2928 073e 440D      		add r20,r4
 2929 0740 551D      		adc r21,r5
 2930 0742 661D      		adc r22,r6
 2931 0744 771D      		adc r23,r7
 2932 0746 00C0      		rjmp .L126
 2933               	.L128:
 2934               	.LVL310:
1712:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 2935               		.loc 1 1712 0
 2936 0748 D701      		movw r26,r14
 2937 074a 1A96      		adiw r26,10
 2938 074c 6C91      		ld r22,X
 2939 074e C601      		movw r24,r12
 2940 0750 8E0D      		add r24,r14
 2941 0752 9F1D      		adc r25,r15
 2942 0754 0E94 0000 		call eeprom_write_byte
 2943               	.LVL311:
 2944 0758 BFEF      		ldi r27,-1
 2945 075a EB1A      		sub r14,r27
 2946 075c FB0A      		sbc r15,r27
 2947               	.LVL312:
 2948 075e 00C0      		rjmp .L127
 2949               	.LVL313:
 2950               	.L129:
 2951 0760 F101      		movw r30,r2
 2952               	.LVL314:
 2953 0762 D101      		movw r26,r2
 2954 0764 A20F      		add r26,r18
 2955 0766 B31F      		adc r27,r19
 2956               	.LBE142:
 2957               	.LBE144:
 2958               	.LBB145:
1735:stk500boot.c  **** 						{
 2959               		.loc 1 1735 0
 2960 0768 7301      		movw r14,r6
 2961               	.LVL315:
 2962 076a 6201      		movw r12,r4
 2963               	.LVL316:
 2964               	.L132:
1757:stk500boot.c  **** 								EEARH	=	((address >> 8));
 2965               		.loc 1 1757 0 discriminator 1
 2966 076c C1BC      		out 0x21,r12
1758:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 2967               		.loc 1 1758 0 discriminator 1
 2968 076e 7727      		clr r23
 2969 0770 6F2D      		mov r22,r15
 2970 0772 5E2D      		mov r21,r14
 2971 0774 4D2D      		mov r20,r13
 2972 0776 42BD      		out 0x22,r20
1759:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 2973               		.loc 1 1759 0 discriminator 1
 2974 0778 4FEF      		ldi r20,-1
 2975 077a C41A      		sub r12,r20
 2976 077c D40A      		sbc r13,r20
 2977 077e E40A      		sbc r14,r20
 2978 0780 F40A      		sbc r15,r20
 2979               	.LVL317:
1760:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 2980               		.loc 1 1760 0 discriminator 1
 2981 0782 F89A      		sbi 0x1f,0
 2982               	.LVL318:
1761:stk500boot.c  **** 								size--;
 2983               		.loc 1 1761 0 discriminator 1
 2984 0784 60B5      		in r22,0x20
 2985 0786 6283      		std Z+2,r22
 2986 0788 3196      		adiw r30,1
 2987               	.LVL319:
1763:stk500boot.c  **** 						}
 2988               		.loc 1 1763 0 discriminator 1
 2989 078a EA17      		cp r30,r26
 2990 078c FB07      		cpc r31,r27
 2991 078e 01F4      		brne .L132
 2992 0790 A901      		movw r20,r18
 2993 0792 4150      		subi r20,1
 2994 0794 5109      		sbc r21,__zero_reg__
 2995 0796 70E0      		ldi r23,0
 2996 0798 60E0      		ldi r22,0
 2997 079a 4F5F      		subi r20,-1
 2998 079c 5F4F      		sbci r21,-1
 2999 079e 6F4F      		sbci r22,-1
 3000 07a0 7F4F      		sbci r23,-1
 3001 07a2 440E      		add r4,r20
 3002 07a4 551E      		adc r5,r21
 3003 07a6 661E      		adc r6,r22
 3004 07a8 771E      		adc r7,r23
 3005 07aa E3E0      		ldi r30,lo8(3)
 3006 07ac F0E0      		ldi r31,0
 3007               	.LVL320:
 3008 07ae EC0F      		add r30,r28
 3009 07b0 FD1F      		adc r31,r29
 3010 07b2 E20F      		add r30,r18
 3011 07b4 F31F      		adc r31,r19
 3012 07b6 00C0      		rjmp .L131
 3013               	.LVL321:
 3014               	.L133:
 3015 07b8 E050      		subi r30,lo8(-(receivedPacket))
 3016 07ba F040      		sbci r31,hi8(-(receivedPacket))
 3017               	.LVL322:
 3018               	.LBE145:
 3019               	.LBB146:
1807:stk500boot.c  **** 				}
 3020               		.loc 1 1807 0
 3021 07bc 4FEF      		ldi r20,lo8(-1)
 3022               	.LVL323:
 3023               	.L135:
1804:stk500boot.c  **** 				{
 3024               		.loc 1 1804 0 discriminator 1
 3025 07be 9F01      		movw r18,r30
 3026 07c0 2050      		subi r18,lo8(receivedPacket)
 3027 07c2 3040      		sbci r19,hi8(receivedPacket)
 3028               	.LVL324:
 3029 07c4 2C15      		cp r18,r12
 3030 07c6 3D05      		cpc r19,r13
 3031 07c8 00F0      		brlo .+2
 3032 07ca 00C0      		rjmp .L137
1807:stk500boot.c  **** 				}
 3033               		.loc 1 1807 0 discriminator 3
 3034 07cc 4193      		st Z+,r20
 3035               	.LVL325:
 3036 07ce 00C0      		rjmp .L135
 3037               	.LVL326:
 3038               	.L138:
 3039               	.LBE146:
1817:stk500boot.c  **** 				receivedPacket[receivedPacketIndex++] = c;
 3040               		.loc 1 1817 0
 3041 07d0 4191      		ld r20,Z+
 3042               	.LVL327:
1818:stk500boot.c  **** 				checksum ^=c;
 3043               		.loc 1 1818 0
 3044 07d2 4D93      		st X+,r20
1819:stk500boot.c  **** 				msgLength--;
 3045               		.loc 1 1819 0
 3046 07d4 B426      		eor r11,r20
 3047               	.LVL328:
 3048 07d6 00C0      		rjmp .L134
 3049               	.LVL329:
 3050               	.L140:
 3051               	.LBB147:
 3052               	.LBB129:
 933:stk500boot.c  ****     memcpy(output, input, 16);
 3053               		.loc 1 933 0
 3054 07d8 C701      		movw r24,r14
 3055               	.LVL330:
 3056 07da 0E94 0000 		call XorWithIv
 3057               	.LVL331:
 934:stk500boot.c  ****     state = (state_t*)output;
 3058               		.loc 1 934 0
 3059 07de 80E1      		ldi r24,lo8(16)
 3060 07e0 F701      		movw r30,r14
 3061 07e2 D801      		movw r26,r16
 3062               		0:
 3063 07e4 0190      		ld r0,Z+
 3064 07e6 0D92      		st X+,r0
 3065 07e8 8A95      		dec r24
 3066 07ea 01F4      		brne 0b
 935:stk500boot.c  ****     Cipher();
 3067               		.loc 1 935 0
 3068 07ec 1093 0000 		sts state+1,r17
 3069 07f0 0093 0000 		sts state,r16
 936:stk500boot.c  ****     Iv = output;
 3070               		.loc 1 936 0
 3071 07f4 0E94 0000 		call Cipher
 3072               	.LVL332:
 937:stk500boot.c  ****     input += 16;
 3073               		.loc 1 937 0
 3074 07f8 1093 0000 		sts Iv+1,r17
 3075 07fc 0093 0000 		sts Iv,r16
 938:stk500boot.c  ****     output += 16;
 3076               		.loc 1 938 0
 3077 0800 B0E1      		ldi r27,16
 3078 0802 EB0E      		add r14,r27
 3079 0804 F11C      		adc r15,__zero_reg__
 3080               	.LVL333:
 939:stk500boot.c  ****     //printf("Step %d - %d", i/16, i);
 3081               		.loc 1 939 0
 3082 0806 005F      		subi r16,-16
 3083 0808 1F4F      		sbci r17,-1
 3084               	.LVL334:
 3085 080a 00C0      		rjmp .L139
 3086               	.LVL335:
 3087               	.L143:
 3088               	.LBE129:
 3089               	.LBE147:
 3090               	.LBB148:
1837:stk500boot.c  **** 			// sendchar(0x58);
 3091               		.loc 1 1837 0 discriminator 3
 3092 080c D801      		movw r26,r16
 3093 080e 8D91      		ld r24,X+
 3094               	.LVL336:
 3095 0810 8D01      		movw r16,r26
 3096               	.LVL337:
 3097 0812 0E94 0000 		call sendchar
 3098               	.LVL338:
 3099 0816 00C0      		rjmp .L142
 3100               	.LBE148:
 3101               		.cfi_endproc
 3102               	.LFE36:
 3104               		.section	.rodata
 3107               	CSWTCH.140:
 3108 0000 0F        		.byte	15
 3109 0001 02        		.byte	2
 3110 0002 0A        		.byte	10
 3111               		.comm	authenticationNumber,4,1
 3112               	.global	authenticationToken
 3113               		.data
 3116               	authenticationToken:
 3117 0000 53        		.byte	83
 3118 0001 EF        		.byte	-17
 3119 0002 34        		.byte	52
 3120 0003 23        		.byte	35
 3121               	.global	aes_buffer
 3124               	aes_buffer:
 3125 0004 03        		.byte	3
 3126 0005 03        		.byte	3
 3127 0006 03        		.byte	3
 3128 0007 03        		.byte	3
 3129 0008 03        		.byte	3
 3130 0009 03        		.byte	3
 3131 000a 03        		.byte	3
 3132 000b 03        		.byte	3
 3133 000c 03        		.byte	3
 3134 000d 03        		.byte	3
 3135 000e 03        		.byte	3
 3136 000f 03        		.byte	3
 3137 0010 03        		.byte	3
 3138 0011 03        		.byte	3
 3139 0012 03        		.byte	3
 3140 0013 03        		.byte	3
 3141 0014 03        		.byte	3
 3142 0015 03        		.byte	3
 3143 0016 03        		.byte	3
 3144 0017 03        		.byte	3
 3145 0018 03        		.byte	3
 3146 0019 03        		.byte	3
 3147 001a 03        		.byte	3
 3148 001b 03        		.byte	3
 3149 001c 03        		.byte	3
 3150 001d 03        		.byte	3
 3151 001e 03        		.byte	3
 3152 001f 03        		.byte	3
 3153 0020 03        		.byte	3
 3154 0021 03        		.byte	3
 3155 0022 03        		.byte	3
 3156 0023 03        		.byte	3
 3157 0024 03        		.byte	3
 3158 0025 03        		.byte	3
 3159 0026 03        		.byte	3
 3160 0027 03        		.byte	3
 3161 0028 03        		.byte	3
 3162 0029 03        		.byte	3
 3163 002a 03        		.byte	3
 3164 002b 03        		.byte	3
 3165 002c 03        		.byte	3
 3166 002d 03        		.byte	3
 3167 002e 03        		.byte	3
 3168 002f 03        		.byte	3
 3169 0030 03        		.byte	3
 3170 0031 03        		.byte	3
 3171 0032 03        		.byte	3
 3172 0033 03        		.byte	3
 3173 0034 03        		.byte	3
 3174 0035 03        		.byte	3
 3175 0036 03        		.byte	3
 3176 0037 03        		.byte	3
 3177 0038 03        		.byte	3
 3178 0039 03        		.byte	3
 3179 003a 03        		.byte	3
 3180 003b 03        		.byte	3
 3181 003c 03        		.byte	3
 3182 003d 03        		.byte	3
 3183 003e 03        		.byte	3
 3184 003f 03        		.byte	3
 3185 0040 03        		.byte	3
 3186 0041 03        		.byte	3
 3187 0042 03        		.byte	3
 3188 0043 03        		.byte	3
 3189 0044 03        		.byte	3
 3190 0045 03        		.byte	3
 3191 0046 03        		.byte	3
 3192 0047 03        		.byte	3
 3193 0048 03        		.byte	3
 3194 0049 03        		.byte	3
 3195 004a 03        		.byte	3
 3196 004b 03        		.byte	3
 3197 004c 03        		.byte	3
 3198 004d 03        		.byte	3
 3199 004e 03        		.byte	3
 3200 004f 03        		.byte	3
 3201 0050 03        		.byte	3
 3202 0051 03        		.byte	3
 3203 0052 03        		.byte	3
 3204 0053 03        		.byte	3
 3205 0054 03        		.byte	3
 3206 0055 03        		.byte	3
 3207 0056 03        		.byte	3
 3208 0057 03        		.byte	3
 3209 0058 03        		.byte	3
 3210 0059 03        		.byte	3
 3211 005a 03        		.byte	3
 3212 005b 03        		.byte	3
 3213 005c 03        		.byte	3
 3214 005d 03        		.byte	3
 3215 005e 03        		.byte	3
 3216 005f 03        		.byte	3
 3217 0060 03        		.byte	3
 3218 0061 03        		.byte	3
 3219 0062 03        		.byte	3
 3220 0063 03        		.byte	3
 3221 0064 03        		.byte	3
 3222 0065 03        		.byte	3
 3223 0066 03        		.byte	3
 3224 0067 03        		.byte	3
 3225 0068 03        		.byte	3
 3226 0069 03        		.byte	3
 3227 006a 03        		.byte	3
 3228 006b 03        		.byte	3
 3229 006c 03        		.byte	3
 3230 006d 03        		.byte	3
 3231 006e 03        		.byte	3
 3232 006f 03        		.byte	3
 3233 0070 03        		.byte	3
 3234 0071 03        		.byte	3
 3235 0072 03        		.byte	3
 3236 0073 03        		.byte	3
 3237 0074 03        		.byte	3
 3238 0075 03        		.byte	3
 3239 0076 03        		.byte	3
 3240 0077 03        		.byte	3
 3241 0078 03        		.byte	3
 3242 0079 03        		.byte	3
 3243 007a 03        		.byte	3
 3244 007b 03        		.byte	3
 3245 007c 03        		.byte	3
 3246 007d 03        		.byte	3
 3247 007e 03        		.byte	3
 3248 007f 03        		.byte	3
 3249 0080 03        		.byte	3
 3250 0081 03        		.byte	3
 3251 0082 03        		.byte	3
 3252 0083 03        		.byte	3
 3253 0084 03        		.byte	3
 3254 0085 03        		.byte	3
 3255 0086 03        		.byte	3
 3256 0087 03        		.byte	3
 3257 0088 03        		.byte	3
 3258 0089 03        		.byte	3
 3259 008a 03        		.byte	3
 3260 008b 03        		.byte	3
 3261 008c 03        		.byte	3
 3262 008d 03        		.byte	3
 3263 008e 03        		.byte	3
 3264 008f 03        		.byte	3
 3265 0090 03        		.byte	3
 3266 0091 03        		.byte	3
 3267 0092 03        		.byte	3
 3268 0093 03        		.byte	3
 3269 0094 03        		.byte	3
 3270 0095 03        		.byte	3
 3271 0096 03        		.byte	3
 3272 0097 03        		.byte	3
 3273 0098 03        		.byte	3
 3274 0099 03        		.byte	3
 3275 009a 03        		.byte	3
 3276 009b 03        		.byte	3
 3277 009c 03        		.byte	3
 3278 009d 03        		.byte	3
 3279 009e 03        		.byte	3
 3280 009f 03        		.byte	3
 3281 00a0 03        		.byte	3
 3282 00a1 03        		.byte	3
 3283 00a2 03        		.byte	3
 3284 00a3 03        		.byte	3
 3285 00a4 03        		.byte	3
 3286 00a5 03        		.byte	3
 3287 00a6 03        		.byte	3
 3288 00a7 03        		.byte	3
 3289 00a8 03        		.byte	3
 3290 00a9 03        		.byte	3
 3291 00aa 03        		.byte	3
 3292 00ab 03        		.byte	3
 3293 00ac 03        		.byte	3
 3294 00ad 03        		.byte	3
 3295 00ae 03        		.byte	3
 3296 00af 03        		.byte	3
 3297 00b0 03        		.byte	3
 3298 00b1 03        		.byte	3
 3299 00b2 03        		.byte	3
 3300 00b3 03        		.byte	3
 3301 00b4 03        		.byte	3
 3302 00b5 03        		.byte	3
 3303 00b6 03        		.byte	3
 3304 00b7 03        		.byte	3
 3305 00b8 03        		.byte	3
 3306 00b9 03        		.byte	3
 3307 00ba 03        		.byte	3
 3308 00bb 03        		.byte	3
 3309 00bc 03        		.byte	3
 3310 00bd 03        		.byte	3
 3311 00be 03        		.byte	3
 3312 00bf 03        		.byte	3
 3313 00c0 03        		.byte	3
 3314 00c1 03        		.byte	3
 3315 00c2 03        		.byte	3
 3316 00c3 03        		.byte	3
 3317 00c4 03        		.byte	3
 3318 00c5 03        		.byte	3
 3319 00c6 03        		.byte	3
 3320 00c7 03        		.byte	3
 3321 00c8 03        		.byte	3
 3322 00c9 03        		.byte	3
 3323 00ca 03        		.byte	3
 3324 00cb 03        		.byte	3
 3325 00cc 03        		.byte	3
 3326 00cd 03        		.byte	3
 3327 00ce 03        		.byte	3
 3328 00cf 03        		.byte	3
 3329 00d0 03        		.byte	3
 3330 00d1 03        		.byte	3
 3331 00d2 03        		.byte	3
 3332 00d3 03        		.byte	3
 3333 00d4 03        		.byte	3
 3334 00d5 03        		.byte	3
 3335 00d6 03        		.byte	3
 3336 00d7 03        		.byte	3
 3337 00d8 03        		.byte	3
 3338 00d9 03        		.byte	3
 3339 00da 03        		.byte	3
 3340 00db 03        		.byte	3
 3341 00dc 03        		.byte	3
 3342 00dd 03        		.byte	3
 3343 00de 03        		.byte	3
 3344 00df 03        		.byte	3
 3345 00e0 03        		.byte	3
 3346 00e1 03        		.byte	3
 3347 00e2 03        		.byte	3
 3348 00e3 03        		.byte	3
 3349 00e4 03        		.byte	3
 3350 00e5 03        		.byte	3
 3351 00e6 03        		.byte	3
 3352 00e7 03        		.byte	3
 3353 00e8 03        		.byte	3
 3354 00e9 03        		.byte	3
 3355 00ea 03        		.byte	3
 3356 00eb 03        		.byte	3
 3357 00ec 03        		.byte	3
 3358 00ed 03        		.byte	3
 3359 00ee 03        		.byte	3
 3360 00ef 03        		.byte	3
 3361 00f0 03        		.byte	3
 3362 00f1 03        		.byte	3
 3363 00f2 03        		.byte	3
 3364 00f3 03        		.byte	3
 3365 00f4 03        		.byte	3
 3366 00f5 03        		.byte	3
 3367 00f6 03        		.byte	3
 3368 00f7 03        		.byte	3
 3369 00f8 03        		.byte	3
 3370 00f9 03        		.byte	3
 3371 00fa 03        		.byte	3
 3372 00fb 03        		.byte	3
 3373 00fc 03        		.byte	3
 3374 00fd 03        		.byte	3
 3375 00fe 03        		.byte	3
 3376 00ff 03        		.byte	3
 3377 0100 03        		.byte	3
 3378 0101 03        		.byte	3
 3379 0102 03        		.byte	3
 3380 0103 03        		.byte	3
 3381 0104 03        		.byte	3
 3382 0105 03        		.byte	3
 3383 0106 03        		.byte	3
 3384 0107 03        		.byte	3
 3385 0108 03        		.byte	3
 3386 0109 03        		.byte	3
 3387 010a 03        		.byte	3
 3388 010b 03        		.byte	3
 3389 010c 03        		.byte	3
 3390 010d 03        		.byte	3
 3391 010e 03        		.byte	3
 3392 010f 03        		.byte	3
 3393 0110 03        		.byte	3
 3394 0111 03        		.byte	3
 3395 0112 03        		.byte	3
 3396 0113 03        		.byte	3
 3397 0114 03        		.byte	3
 3398 0115 03        		.byte	3
 3399 0116 03        		.byte	3
 3400 0117 03        		.byte	3
 3401 0118 03        		.byte	3
 3402 0119 03        		.byte	3
 3403 011a 03        		.byte	3
 3404 011b 03        		.byte	3
 3405 011c 03        		.byte	3
 3406 011d 03        		.byte	3
 3407 011e 03        		.byte	3
 3408 011f 03        		.byte	3
 3409 0120 03        		.byte	3
 3410 0121 03        		.byte	3
 3411 0122 03        		.byte	3
 3412 0123 03        		.byte	3
 3413               	.global	receivedPacket
 3416               	receivedPacket:
 3417 0124 04        		.byte	4
 3418 0125 04        		.byte	4
 3419 0126 04        		.byte	4
 3420 0127 04        		.byte	4
 3421 0128 04        		.byte	4
 3422 0129 04        		.byte	4
 3423 012a 04        		.byte	4
 3424 012b 04        		.byte	4
 3425 012c 04        		.byte	4
 3426 012d 04        		.byte	4
 3427 012e 04        		.byte	4
 3428 012f 04        		.byte	4
 3429 0130 04        		.byte	4
 3430 0131 04        		.byte	4
 3431 0132 04        		.byte	4
 3432 0133 04        		.byte	4
 3433 0134 04        		.byte	4
 3434 0135 04        		.byte	4
 3435 0136 04        		.byte	4
 3436 0137 04        		.byte	4
 3437 0138 04        		.byte	4
 3438 0139 04        		.byte	4
 3439 013a 04        		.byte	4
 3440 013b 04        		.byte	4
 3441 013c 04        		.byte	4
 3442 013d 04        		.byte	4
 3443 013e 04        		.byte	4
 3444 013f 04        		.byte	4
 3445 0140 04        		.byte	4
 3446 0141 04        		.byte	4
 3447 0142 04        		.byte	4
 3448 0143 04        		.byte	4
 3449 0144 04        		.byte	4
 3450 0145 04        		.byte	4
 3451 0146 04        		.byte	4
 3452 0147 04        		.byte	4
 3453 0148 04        		.byte	4
 3454 0149 04        		.byte	4
 3455 014a 04        		.byte	4
 3456 014b 04        		.byte	4
 3457 014c 04        		.byte	4
 3458 014d 04        		.byte	4
 3459 014e 04        		.byte	4
 3460 014f 04        		.byte	4
 3461 0150 04        		.byte	4
 3462 0151 04        		.byte	4
 3463 0152 04        		.byte	4
 3464 0153 04        		.byte	4
 3465 0154 04        		.byte	4
 3466 0155 04        		.byte	4
 3467 0156 04        		.byte	4
 3468 0157 04        		.byte	4
 3469 0158 04        		.byte	4
 3470 0159 04        		.byte	4
 3471 015a 04        		.byte	4
 3472 015b 04        		.byte	4
 3473 015c 04        		.byte	4
 3474 015d 04        		.byte	4
 3475 015e 04        		.byte	4
 3476 015f 04        		.byte	4
 3477 0160 04        		.byte	4
 3478 0161 04        		.byte	4
 3479 0162 04        		.byte	4
 3480 0163 04        		.byte	4
 3481 0164 04        		.byte	4
 3482 0165 04        		.byte	4
 3483 0166 04        		.byte	4
 3484 0167 04        		.byte	4
 3485 0168 04        		.byte	4
 3486 0169 04        		.byte	4
 3487 016a 04        		.byte	4
 3488 016b 04        		.byte	4
 3489 016c 04        		.byte	4
 3490 016d 04        		.byte	4
 3491 016e 04        		.byte	4
 3492 016f 04        		.byte	4
 3493 0170 04        		.byte	4
 3494 0171 04        		.byte	4
 3495 0172 04        		.byte	4
 3496 0173 04        		.byte	4
 3497 0174 04        		.byte	4
 3498 0175 04        		.byte	4
 3499 0176 04        		.byte	4
 3500 0177 04        		.byte	4
 3501 0178 04        		.byte	4
 3502 0179 04        		.byte	4
 3503 017a 04        		.byte	4
 3504 017b 04        		.byte	4
 3505 017c 04        		.byte	4
 3506 017d 04        		.byte	4
 3507 017e 04        		.byte	4
 3508 017f 04        		.byte	4
 3509 0180 04        		.byte	4
 3510 0181 04        		.byte	4
 3511 0182 04        		.byte	4
 3512 0183 04        		.byte	4
 3513 0184 04        		.byte	4
 3514 0185 04        		.byte	4
 3515 0186 04        		.byte	4
 3516 0187 04        		.byte	4
 3517 0188 04        		.byte	4
 3518 0189 04        		.byte	4
 3519 018a 04        		.byte	4
 3520 018b 04        		.byte	4
 3521 018c 04        		.byte	4
 3522 018d 04        		.byte	4
 3523 018e 04        		.byte	4
 3524 018f 04        		.byte	4
 3525 0190 04        		.byte	4
 3526 0191 04        		.byte	4
 3527 0192 04        		.byte	4
 3528 0193 04        		.byte	4
 3529 0194 04        		.byte	4
 3530 0195 04        		.byte	4
 3531 0196 04        		.byte	4
 3532 0197 04        		.byte	4
 3533 0198 04        		.byte	4
 3534 0199 04        		.byte	4
 3535 019a 04        		.byte	4
 3536 019b 04        		.byte	4
 3537 019c 04        		.byte	4
 3538 019d 04        		.byte	4
 3539 019e 04        		.byte	4
 3540 019f 04        		.byte	4
 3541 01a0 04        		.byte	4
 3542 01a1 04        		.byte	4
 3543 01a2 04        		.byte	4
 3544 01a3 04        		.byte	4
 3545 01a4 04        		.byte	4
 3546 01a5 04        		.byte	4
 3547 01a6 04        		.byte	4
 3548 01a7 04        		.byte	4
 3549 01a8 04        		.byte	4
 3550 01a9 04        		.byte	4
 3551 01aa 04        		.byte	4
 3552 01ab 04        		.byte	4
 3553 01ac 04        		.byte	4
 3554 01ad 04        		.byte	4
 3555 01ae 04        		.byte	4
 3556 01af 04        		.byte	4
 3557 01b0 04        		.byte	4
 3558 01b1 04        		.byte	4
 3559 01b2 04        		.byte	4
 3560 01b3 04        		.byte	4
 3561 01b4 04        		.byte	4
 3562 01b5 04        		.byte	4
 3563 01b6 04        		.byte	4
 3564 01b7 04        		.byte	4
 3565 01b8 04        		.byte	4
 3566 01b9 04        		.byte	4
 3567 01ba 04        		.byte	4
 3568 01bb 04        		.byte	4
 3569 01bc 04        		.byte	4
 3570 01bd 04        		.byte	4
 3571 01be 04        		.byte	4
 3572 01bf 04        		.byte	4
 3573 01c0 04        		.byte	4
 3574 01c1 04        		.byte	4
 3575 01c2 04        		.byte	4
 3576 01c3 04        		.byte	4
 3577 01c4 04        		.byte	4
 3578 01c5 04        		.byte	4
 3579 01c6 04        		.byte	4
 3580 01c7 04        		.byte	4
 3581 01c8 04        		.byte	4
 3582 01c9 04        		.byte	4
 3583 01ca 04        		.byte	4
 3584 01cb 04        		.byte	4
 3585 01cc 04        		.byte	4
 3586 01cd 04        		.byte	4
 3587 01ce 04        		.byte	4
 3588 01cf 04        		.byte	4
 3589 01d0 04        		.byte	4
 3590 01d1 04        		.byte	4
 3591 01d2 04        		.byte	4
 3592 01d3 04        		.byte	4
 3593 01d4 04        		.byte	4
 3594 01d5 04        		.byte	4
 3595 01d6 04        		.byte	4
 3596 01d7 04        		.byte	4
 3597 01d8 04        		.byte	4
 3598 01d9 04        		.byte	4
 3599 01da 04        		.byte	4
 3600 01db 04        		.byte	4
 3601 01dc 04        		.byte	4
 3602 01dd 04        		.byte	4
 3603 01de 04        		.byte	4
 3604 01df 04        		.byte	4
 3605 01e0 04        		.byte	4
 3606 01e1 04        		.byte	4
 3607 01e2 04        		.byte	4
 3608 01e3 04        		.byte	4
 3609 01e4 04        		.byte	4
 3610 01e5 04        		.byte	4
 3611 01e6 04        		.byte	4
 3612 01e7 04        		.byte	4
 3613 01e8 04        		.byte	4
 3614 01e9 04        		.byte	4
 3615 01ea 04        		.byte	4
 3616 01eb 04        		.byte	4
 3617 01ec 04        		.byte	4
 3618 01ed 04        		.byte	4
 3619 01ee 04        		.byte	4
 3620 01ef 04        		.byte	4
 3621 01f0 04        		.byte	4
 3622 01f1 04        		.byte	4
 3623 01f2 04        		.byte	4
 3624 01f3 04        		.byte	4
 3625 01f4 04        		.byte	4
 3626 01f5 04        		.byte	4
 3627 01f6 04        		.byte	4
 3628 01f7 04        		.byte	4
 3629 01f8 04        		.byte	4
 3630 01f9 04        		.byte	4
 3631 01fa 04        		.byte	4
 3632 01fb 04        		.byte	4
 3633 01fc 04        		.byte	4
 3634 01fd 04        		.byte	4
 3635 01fe 04        		.byte	4
 3636 01ff 04        		.byte	4
 3637 0200 04        		.byte	4
 3638 0201 04        		.byte	4
 3639 0202 04        		.byte	4
 3640 0203 04        		.byte	4
 3641 0204 04        		.byte	4
 3642 0205 04        		.byte	4
 3643 0206 04        		.byte	4
 3644 0207 04        		.byte	4
 3645 0208 04        		.byte	4
 3646 0209 04        		.byte	4
 3647 020a 04        		.byte	4
 3648 020b 04        		.byte	4
 3649 020c 04        		.byte	4
 3650 020d 04        		.byte	4
 3651 020e 04        		.byte	4
 3652 020f 04        		.byte	4
 3653 0210 04        		.byte	4
 3654 0211 04        		.byte	4
 3655 0212 04        		.byte	4
 3656 0213 04        		.byte	4
 3657 0214 04        		.byte	4
 3658 0215 04        		.byte	4
 3659 0216 04        		.byte	4
 3660 0217 04        		.byte	4
 3661 0218 04        		.byte	4
 3662 0219 04        		.byte	4
 3663 021a 04        		.byte	4
 3664 021b 04        		.byte	4
 3665 021c 04        		.byte	4
 3666 021d 04        		.byte	4
 3667 021e 04        		.byte	4
 3668 021f 04        		.byte	4
 3669 0220 04        		.byte	4
 3670 0221 04        		.byte	4
 3671 0222 04        		.byte	4
 3672 0223 04        		.byte	4
 3673 0224 04        		.byte	4
 3674 0225 04        		.byte	4
 3675 0226 04        		.byte	4
 3676 0227 04        		.byte	4
 3677 0228 04        		.byte	4
 3678 0229 04        		.byte	4
 3679 022a 04        		.byte	4
 3680 022b 04        		.byte	4
 3681 022c 04        		.byte	4
 3682 022d 04        		.byte	4
 3683 022e 04        		.byte	4
 3684 022f 04        		.byte	4
 3685 0230 04        		.byte	4
 3686 0231 04        		.byte	4
 3687 0232 04        		.byte	4
 3688 0233 04        		.byte	4
 3689 0234 04        		.byte	4
 3690 0235 04        		.byte	4
 3691 0236 04        		.byte	4
 3692 0237 04        		.byte	4
 3693 0238 04        		.byte	4
 3694 0239 04        		.byte	4
 3695 023a 04        		.byte	4
 3696 023b 04        		.byte	4
 3697 023c 04        		.byte	4
 3698 023d 04        		.byte	4
 3699 023e 04        		.byte	4
 3700 023f 04        		.byte	4
 3701 0240 04        		.byte	4
 3702 0241 04        		.byte	4
 3703 0242 04        		.byte	4
 3704 0243 04        		.byte	4
 3705               	.global	app_start
 3706               		.section .bss
 3709               	app_start:
 3710 0000 0000      		.zero	2
 3711               		.section	.rodata
 3714               	Rcon:
 3715 0003 8D        		.byte	-115
 3716 0004 01        		.byte	1
 3717 0005 02        		.byte	2
 3718 0006 04        		.byte	4
 3719 0007 08        		.byte	8
 3720 0008 10        		.byte	16
 3721 0009 20        		.byte	32
 3722 000a 40        		.byte	64
 3723 000b 80        		.byte	-128
 3724 000c 1B        		.byte	27
 3725 000d 36        		.byte	54
 3726 000e 6C        		.byte	108
 3727 000f D8        		.byte	-40
 3728 0010 AB        		.byte	-85
 3729 0011 4D        		.byte	77
 3730 0012 9A        		.byte	-102
 3731 0013 2F        		.byte	47
 3732 0014 5E        		.byte	94
 3733 0015 BC        		.byte	-68
 3734 0016 63        		.byte	99
 3735 0017 C6        		.byte	-58
 3736 0018 97        		.byte	-105
 3737 0019 35        		.byte	53
 3738 001a 6A        		.byte	106
 3739 001b D4        		.byte	-44
 3740 001c B3        		.byte	-77
 3741 001d 7D        		.byte	125
 3742 001e FA        		.byte	-6
 3743 001f EF        		.byte	-17
 3744 0020 C5        		.byte	-59
 3745 0021 91        		.byte	-111
 3746 0022 39        		.byte	57
 3747 0023 72        		.byte	114
 3748 0024 E4        		.byte	-28
 3749 0025 D3        		.byte	-45
 3750 0026 BD        		.byte	-67
 3751 0027 61        		.byte	97
 3752 0028 C2        		.byte	-62
 3753 0029 9F        		.byte	-97
 3754 002a 25        		.byte	37
 3755 002b 4A        		.byte	74
 3756 002c 94        		.byte	-108
 3757 002d 33        		.byte	51
 3758 002e 66        		.byte	102
 3759 002f CC        		.byte	-52
 3760 0030 83        		.byte	-125
 3761 0031 1D        		.byte	29
 3762 0032 3A        		.byte	58
 3763 0033 74        		.byte	116
 3764 0034 E8        		.byte	-24
 3765 0035 CB        		.byte	-53
 3766 0036 8D        		.byte	-115
 3767 0037 01        		.byte	1
 3768 0038 02        		.byte	2
 3769 0039 04        		.byte	4
 3770 003a 08        		.byte	8
 3771 003b 10        		.byte	16
 3772 003c 20        		.byte	32
 3773 003d 40        		.byte	64
 3774 003e 80        		.byte	-128
 3775 003f 1B        		.byte	27
 3776 0040 36        		.byte	54
 3777 0041 6C        		.byte	108
 3778 0042 D8        		.byte	-40
 3779 0043 AB        		.byte	-85
 3780 0044 4D        		.byte	77
 3781 0045 9A        		.byte	-102
 3782 0046 2F        		.byte	47
 3783 0047 5E        		.byte	94
 3784 0048 BC        		.byte	-68
 3785 0049 63        		.byte	99
 3786 004a C6        		.byte	-58
 3787 004b 97        		.byte	-105
 3788 004c 35        		.byte	53
 3789 004d 6A        		.byte	106
 3790 004e D4        		.byte	-44
 3791 004f B3        		.byte	-77
 3792 0050 7D        		.byte	125
 3793 0051 FA        		.byte	-6
 3794 0052 EF        		.byte	-17
 3795 0053 C5        		.byte	-59
 3796 0054 91        		.byte	-111
 3797 0055 39        		.byte	57
 3798 0056 72        		.byte	114
 3799 0057 E4        		.byte	-28
 3800 0058 D3        		.byte	-45
 3801 0059 BD        		.byte	-67
 3802 005a 61        		.byte	97
 3803 005b C2        		.byte	-62
 3804 005c 9F        		.byte	-97
 3805 005d 25        		.byte	37
 3806 005e 4A        		.byte	74
 3807 005f 94        		.byte	-108
 3808 0060 33        		.byte	51
 3809 0061 66        		.byte	102
 3810 0062 CC        		.byte	-52
 3811 0063 83        		.byte	-125
 3812 0064 1D        		.byte	29
 3813 0065 3A        		.byte	58
 3814 0066 74        		.byte	116
 3815 0067 E8        		.byte	-24
 3816 0068 CB        		.byte	-53
 3817 0069 8D        		.byte	-115
 3818 006a 01        		.byte	1
 3819 006b 02        		.byte	2
 3820 006c 04        		.byte	4
 3821 006d 08        		.byte	8
 3822 006e 10        		.byte	16
 3823 006f 20        		.byte	32
 3824 0070 40        		.byte	64
 3825 0071 80        		.byte	-128
 3826 0072 1B        		.byte	27
 3827 0073 36        		.byte	54
 3828 0074 6C        		.byte	108
 3829 0075 D8        		.byte	-40
 3830 0076 AB        		.byte	-85
 3831 0077 4D        		.byte	77
 3832 0078 9A        		.byte	-102
 3833 0079 2F        		.byte	47
 3834 007a 5E        		.byte	94
 3835 007b BC        		.byte	-68
 3836 007c 63        		.byte	99
 3837 007d C6        		.byte	-58
 3838 007e 97        		.byte	-105
 3839 007f 35        		.byte	53
 3840 0080 6A        		.byte	106
 3841 0081 D4        		.byte	-44
 3842 0082 B3        		.byte	-77
 3843 0083 7D        		.byte	125
 3844 0084 FA        		.byte	-6
 3845 0085 EF        		.byte	-17
 3846 0086 C5        		.byte	-59
 3847 0087 91        		.byte	-111
 3848 0088 39        		.byte	57
 3849 0089 72        		.byte	114
 3850 008a E4        		.byte	-28
 3851 008b D3        		.byte	-45
 3852 008c BD        		.byte	-67
 3853 008d 61        		.byte	97
 3854 008e C2        		.byte	-62
 3855 008f 9F        		.byte	-97
 3856 0090 25        		.byte	37
 3857 0091 4A        		.byte	74
 3858 0092 94        		.byte	-108
 3859 0093 33        		.byte	51
 3860 0094 66        		.byte	102
 3861 0095 CC        		.byte	-52
 3862 0096 83        		.byte	-125
 3863 0097 1D        		.byte	29
 3864 0098 3A        		.byte	58
 3865 0099 74        		.byte	116
 3866 009a E8        		.byte	-24
 3867 009b CB        		.byte	-53
 3868 009c 8D        		.byte	-115
 3869 009d 01        		.byte	1
 3870 009e 02        		.byte	2
 3871 009f 04        		.byte	4
 3872 00a0 08        		.byte	8
 3873 00a1 10        		.byte	16
 3874 00a2 20        		.byte	32
 3875 00a3 40        		.byte	64
 3876 00a4 80        		.byte	-128
 3877 00a5 1B        		.byte	27
 3878 00a6 36        		.byte	54
 3879 00a7 6C        		.byte	108
 3880 00a8 D8        		.byte	-40
 3881 00a9 AB        		.byte	-85
 3882 00aa 4D        		.byte	77
 3883 00ab 9A        		.byte	-102
 3884 00ac 2F        		.byte	47
 3885 00ad 5E        		.byte	94
 3886 00ae BC        		.byte	-68
 3887 00af 63        		.byte	99
 3888 00b0 C6        		.byte	-58
 3889 00b1 97        		.byte	-105
 3890 00b2 35        		.byte	53
 3891 00b3 6A        		.byte	106
 3892 00b4 D4        		.byte	-44
 3893 00b5 B3        		.byte	-77
 3894 00b6 7D        		.byte	125
 3895 00b7 FA        		.byte	-6
 3896 00b8 EF        		.byte	-17
 3897 00b9 C5        		.byte	-59
 3898 00ba 91        		.byte	-111
 3899 00bb 39        		.byte	57
 3900 00bc 72        		.byte	114
 3901 00bd E4        		.byte	-28
 3902 00be D3        		.byte	-45
 3903 00bf BD        		.byte	-67
 3904 00c0 61        		.byte	97
 3905 00c1 C2        		.byte	-62
 3906 00c2 9F        		.byte	-97
 3907 00c3 25        		.byte	37
 3908 00c4 4A        		.byte	74
 3909 00c5 94        		.byte	-108
 3910 00c6 33        		.byte	51
 3911 00c7 66        		.byte	102
 3912 00c8 CC        		.byte	-52
 3913 00c9 83        		.byte	-125
 3914 00ca 1D        		.byte	29
 3915 00cb 3A        		.byte	58
 3916 00cc 74        		.byte	116
 3917 00cd E8        		.byte	-24
 3918 00ce CB        		.byte	-53
 3919 00cf 8D        		.byte	-115
 3920 00d0 01        		.byte	1
 3921 00d1 02        		.byte	2
 3922 00d2 04        		.byte	4
 3923 00d3 08        		.byte	8
 3924 00d4 10        		.byte	16
 3925 00d5 20        		.byte	32
 3926 00d6 40        		.byte	64
 3927 00d7 80        		.byte	-128
 3928 00d8 1B        		.byte	27
 3929 00d9 36        		.byte	54
 3930 00da 6C        		.byte	108
 3931 00db D8        		.byte	-40
 3932 00dc AB        		.byte	-85
 3933 00dd 4D        		.byte	77
 3934 00de 9A        		.byte	-102
 3935 00df 2F        		.byte	47
 3936 00e0 5E        		.byte	94
 3937 00e1 BC        		.byte	-68
 3938 00e2 63        		.byte	99
 3939 00e3 C6        		.byte	-58
 3940 00e4 97        		.byte	-105
 3941 00e5 35        		.byte	53
 3942 00e6 6A        		.byte	106
 3943 00e7 D4        		.byte	-44
 3944 00e8 B3        		.byte	-77
 3945 00e9 7D        		.byte	125
 3946 00ea FA        		.byte	-6
 3947 00eb EF        		.byte	-17
 3948 00ec C5        		.byte	-59
 3949 00ed 91        		.byte	-111
 3950 00ee 39        		.byte	57
 3951 00ef 72        		.byte	114
 3952 00f0 E4        		.byte	-28
 3953 00f1 D3        		.byte	-45
 3954 00f2 BD        		.byte	-67
 3955 00f3 61        		.byte	97
 3956 00f4 C2        		.byte	-62
 3957 00f5 9F        		.byte	-97
 3958 00f6 25        		.byte	37
 3959 00f7 4A        		.byte	74
 3960 00f8 94        		.byte	-108
 3961 00f9 33        		.byte	51
 3962 00fa 66        		.byte	102
 3963 00fb CC        		.byte	-52
 3964 00fc 83        		.byte	-125
 3965 00fd 1D        		.byte	29
 3966 00fe 3A        		.byte	58
 3967 00ff 74        		.byte	116
 3968 0100 E8        		.byte	-24
 3969 0101 CB        		.byte	-53
 3972               	rsbox:
 3973 0102 52        		.byte	82
 3974 0103 09        		.byte	9
 3975 0104 6A        		.byte	106
 3976 0105 D5        		.byte	-43
 3977 0106 30        		.byte	48
 3978 0107 36        		.byte	54
 3979 0108 A5        		.byte	-91
 3980 0109 38        		.byte	56
 3981 010a BF        		.byte	-65
 3982 010b 40        		.byte	64
 3983 010c A3        		.byte	-93
 3984 010d 9E        		.byte	-98
 3985 010e 81        		.byte	-127
 3986 010f F3        		.byte	-13
 3987 0110 D7        		.byte	-41
 3988 0111 FB        		.byte	-5
 3989 0112 7C        		.byte	124
 3990 0113 E3        		.byte	-29
 3991 0114 39        		.byte	57
 3992 0115 82        		.byte	-126
 3993 0116 9B        		.byte	-101
 3994 0117 2F        		.byte	47
 3995 0118 FF        		.byte	-1
 3996 0119 87        		.byte	-121
 3997 011a 34        		.byte	52
 3998 011b 8E        		.byte	-114
 3999 011c 43        		.byte	67
 4000 011d 44        		.byte	68
 4001 011e C4        		.byte	-60
 4002 011f DE        		.byte	-34
 4003 0120 E9        		.byte	-23
 4004 0121 CB        		.byte	-53
 4005 0122 54        		.byte	84
 4006 0123 7B        		.byte	123
 4007 0124 94        		.byte	-108
 4008 0125 32        		.byte	50
 4009 0126 A6        		.byte	-90
 4010 0127 C2        		.byte	-62
 4011 0128 23        		.byte	35
 4012 0129 3D        		.byte	61
 4013 012a EE        		.byte	-18
 4014 012b 4C        		.byte	76
 4015 012c 95        		.byte	-107
 4016 012d 0B        		.byte	11
 4017 012e 42        		.byte	66
 4018 012f FA        		.byte	-6
 4019 0130 C3        		.byte	-61
 4020 0131 4E        		.byte	78
 4021 0132 08        		.byte	8
 4022 0133 2E        		.byte	46
 4023 0134 A1        		.byte	-95
 4024 0135 66        		.byte	102
 4025 0136 28        		.byte	40
 4026 0137 D9        		.byte	-39
 4027 0138 24        		.byte	36
 4028 0139 B2        		.byte	-78
 4029 013a 76        		.byte	118
 4030 013b 5B        		.byte	91
 4031 013c A2        		.byte	-94
 4032 013d 49        		.byte	73
 4033 013e 6D        		.byte	109
 4034 013f 8B        		.byte	-117
 4035 0140 D1        		.byte	-47
 4036 0141 25        		.byte	37
 4037 0142 72        		.byte	114
 4038 0143 F8        		.byte	-8
 4039 0144 F6        		.byte	-10
 4040 0145 64        		.byte	100
 4041 0146 86        		.byte	-122
 4042 0147 68        		.byte	104
 4043 0148 98        		.byte	-104
 4044 0149 16        		.byte	22
 4045 014a D4        		.byte	-44
 4046 014b A4        		.byte	-92
 4047 014c 5C        		.byte	92
 4048 014d CC        		.byte	-52
 4049 014e 5D        		.byte	93
 4050 014f 65        		.byte	101
 4051 0150 B6        		.byte	-74
 4052 0151 92        		.byte	-110
 4053 0152 6C        		.byte	108
 4054 0153 70        		.byte	112
 4055 0154 48        		.byte	72
 4056 0155 50        		.byte	80
 4057 0156 FD        		.byte	-3
 4058 0157 ED        		.byte	-19
 4059 0158 B9        		.byte	-71
 4060 0159 DA        		.byte	-38
 4061 015a 5E        		.byte	94
 4062 015b 15        		.byte	21
 4063 015c 46        		.byte	70
 4064 015d 57        		.byte	87
 4065 015e A7        		.byte	-89
 4066 015f 8D        		.byte	-115
 4067 0160 9D        		.byte	-99
 4068 0161 84        		.byte	-124
 4069 0162 90        		.byte	-112
 4070 0163 D8        		.byte	-40
 4071 0164 AB        		.byte	-85
 4072 0165 00        		.byte	0
 4073 0166 8C        		.byte	-116
 4074 0167 BC        		.byte	-68
 4075 0168 D3        		.byte	-45
 4076 0169 0A        		.byte	10
 4077 016a F7        		.byte	-9
 4078 016b E4        		.byte	-28
 4079 016c 58        		.byte	88
 4080 016d 05        		.byte	5
 4081 016e B8        		.byte	-72
 4082 016f B3        		.byte	-77
 4083 0170 45        		.byte	69
 4084 0171 06        		.byte	6
 4085 0172 D0        		.byte	-48
 4086 0173 2C        		.byte	44
 4087 0174 1E        		.byte	30
 4088 0175 8F        		.byte	-113
 4089 0176 CA        		.byte	-54
 4090 0177 3F        		.byte	63
 4091 0178 0F        		.byte	15
 4092 0179 02        		.byte	2
 4093 017a C1        		.byte	-63
 4094 017b AF        		.byte	-81
 4095 017c BD        		.byte	-67
 4096 017d 03        		.byte	3
 4097 017e 01        		.byte	1
 4098 017f 13        		.byte	19
 4099 0180 8A        		.byte	-118
 4100 0181 6B        		.byte	107
 4101 0182 3A        		.byte	58
 4102 0183 91        		.byte	-111
 4103 0184 11        		.byte	17
 4104 0185 41        		.byte	65
 4105 0186 4F        		.byte	79
 4106 0187 67        		.byte	103
 4107 0188 DC        		.byte	-36
 4108 0189 EA        		.byte	-22
 4109 018a 97        		.byte	-105
 4110 018b F2        		.byte	-14
 4111 018c CF        		.byte	-49
 4112 018d CE        		.byte	-50
 4113 018e F0        		.byte	-16
 4114 018f B4        		.byte	-76
 4115 0190 E6        		.byte	-26
 4116 0191 73        		.byte	115
 4117 0192 96        		.byte	-106
 4118 0193 AC        		.byte	-84
 4119 0194 74        		.byte	116
 4120 0195 22        		.byte	34
 4121 0196 E7        		.byte	-25
 4122 0197 AD        		.byte	-83
 4123 0198 35        		.byte	53
 4124 0199 85        		.byte	-123
 4125 019a E2        		.byte	-30
 4126 019b F9        		.byte	-7
 4127 019c 37        		.byte	55
 4128 019d E8        		.byte	-24
 4129 019e 1C        		.byte	28
 4130 019f 75        		.byte	117
 4131 01a0 DF        		.byte	-33
 4132 01a1 6E        		.byte	110
 4133 01a2 47        		.byte	71
 4134 01a3 F1        		.byte	-15
 4135 01a4 1A        		.byte	26
 4136 01a5 71        		.byte	113
 4137 01a6 1D        		.byte	29
 4138 01a7 29        		.byte	41
 4139 01a8 C5        		.byte	-59
 4140 01a9 89        		.byte	-119
 4141 01aa 6F        		.byte	111
 4142 01ab B7        		.byte	-73
 4143 01ac 62        		.byte	98
 4144 01ad 0E        		.byte	14
 4145 01ae AA        		.byte	-86
 4146 01af 18        		.byte	24
 4147 01b0 BE        		.byte	-66
 4148 01b1 1B        		.byte	27
 4149 01b2 FC        		.byte	-4
 4150 01b3 56        		.byte	86
 4151 01b4 3E        		.byte	62
 4152 01b5 4B        		.byte	75
 4153 01b6 C6        		.byte	-58
 4154 01b7 D2        		.byte	-46
 4155 01b8 79        		.byte	121
 4156 01b9 20        		.byte	32
 4157 01ba 9A        		.byte	-102
 4158 01bb DB        		.byte	-37
 4159 01bc C0        		.byte	-64
 4160 01bd FE        		.byte	-2
 4161 01be 78        		.byte	120
 4162 01bf CD        		.byte	-51
 4163 01c0 5A        		.byte	90
 4164 01c1 F4        		.byte	-12
 4165 01c2 1F        		.byte	31
 4166 01c3 DD        		.byte	-35
 4167 01c4 A8        		.byte	-88
 4168 01c5 33        		.byte	51
 4169 01c6 88        		.byte	-120
 4170 01c7 07        		.byte	7
 4171 01c8 C7        		.byte	-57
 4172 01c9 31        		.byte	49
 4173 01ca B1        		.byte	-79
 4174 01cb 12        		.byte	18
 4175 01cc 10        		.byte	16
 4176 01cd 59        		.byte	89
 4177 01ce 27        		.byte	39
 4178 01cf 80        		.byte	-128
 4179 01d0 EC        		.byte	-20
 4180 01d1 5F        		.byte	95
 4181 01d2 60        		.byte	96
 4182 01d3 51        		.byte	81
 4183 01d4 7F        		.byte	127
 4184 01d5 A9        		.byte	-87
 4185 01d6 19        		.byte	25
 4186 01d7 B5        		.byte	-75
 4187 01d8 4A        		.byte	74
 4188 01d9 0D        		.byte	13
 4189 01da 2D        		.byte	45
 4190 01db E5        		.byte	-27
 4191 01dc 7A        		.byte	122
 4192 01dd 9F        		.byte	-97
 4193 01de 93        		.byte	-109
 4194 01df C9        		.byte	-55
 4195 01e0 9C        		.byte	-100
 4196 01e1 EF        		.byte	-17
 4197 01e2 A0        		.byte	-96
 4198 01e3 E0        		.byte	-32
 4199 01e4 3B        		.byte	59
 4200 01e5 4D        		.byte	77
 4201 01e6 AE        		.byte	-82
 4202 01e7 2A        		.byte	42
 4203 01e8 F5        		.byte	-11
 4204 01e9 B0        		.byte	-80
 4205 01ea C8        		.byte	-56
 4206 01eb EB        		.byte	-21
 4207 01ec BB        		.byte	-69
 4208 01ed 3C        		.byte	60
 4209 01ee 83        		.byte	-125
 4210 01ef 53        		.byte	83
 4211 01f0 99        		.byte	-103
 4212 01f1 61        		.byte	97
 4213 01f2 17        		.byte	23
 4214 01f3 2B        		.byte	43
 4215 01f4 04        		.byte	4
 4216 01f5 7E        		.byte	126
 4217 01f6 BA        		.byte	-70
 4218 01f7 77        		.byte	119
 4219 01f8 D6        		.byte	-42
 4220 01f9 26        		.byte	38
 4221 01fa E1        		.byte	-31
 4222 01fb 69        		.byte	105
 4223 01fc 14        		.byte	20
 4224 01fd 63        		.byte	99
 4225 01fe 55        		.byte	85
 4226 01ff 21        		.byte	33
 4227 0200 0C        		.byte	12
 4228 0201 7D        		.byte	125
 4231               	sbox:
 4232 0202 63        		.byte	99
 4233 0203 7C        		.byte	124
 4234 0204 77        		.byte	119
 4235 0205 7B        		.byte	123
 4236 0206 F2        		.byte	-14
 4237 0207 6B        		.byte	107
 4238 0208 6F        		.byte	111
 4239 0209 C5        		.byte	-59
 4240 020a 30        		.byte	48
 4241 020b 01        		.byte	1
 4242 020c 67        		.byte	103
 4243 020d 2B        		.byte	43
 4244 020e FE        		.byte	-2
 4245 020f D7        		.byte	-41
 4246 0210 AB        		.byte	-85
 4247 0211 76        		.byte	118
 4248 0212 CA        		.byte	-54
 4249 0213 82        		.byte	-126
 4250 0214 C9        		.byte	-55
 4251 0215 7D        		.byte	125
 4252 0216 FA        		.byte	-6
 4253 0217 59        		.byte	89
 4254 0218 47        		.byte	71
 4255 0219 F0        		.byte	-16
 4256 021a AD        		.byte	-83
 4257 021b D4        		.byte	-44
 4258 021c A2        		.byte	-94
 4259 021d AF        		.byte	-81
 4260 021e 9C        		.byte	-100
 4261 021f A4        		.byte	-92
 4262 0220 72        		.byte	114
 4263 0221 C0        		.byte	-64
 4264 0222 B7        		.byte	-73
 4265 0223 FD        		.byte	-3
 4266 0224 93        		.byte	-109
 4267 0225 26        		.byte	38
 4268 0226 36        		.byte	54
 4269 0227 3F        		.byte	63
 4270 0228 F7        		.byte	-9
 4271 0229 CC        		.byte	-52
 4272 022a 34        		.byte	52
 4273 022b A5        		.byte	-91
 4274 022c E5        		.byte	-27
 4275 022d F1        		.byte	-15
 4276 022e 71        		.byte	113
 4277 022f D8        		.byte	-40
 4278 0230 31        		.byte	49
 4279 0231 15        		.byte	21
 4280 0232 04        		.byte	4
 4281 0233 C7        		.byte	-57
 4282 0234 23        		.byte	35
 4283 0235 C3        		.byte	-61
 4284 0236 18        		.byte	24
 4285 0237 96        		.byte	-106
 4286 0238 05        		.byte	5
 4287 0239 9A        		.byte	-102
 4288 023a 07        		.byte	7
 4289 023b 12        		.byte	18
 4290 023c 80        		.byte	-128
 4291 023d E2        		.byte	-30
 4292 023e EB        		.byte	-21
 4293 023f 27        		.byte	39
 4294 0240 B2        		.byte	-78
 4295 0241 75        		.byte	117
 4296 0242 09        		.byte	9
 4297 0243 83        		.byte	-125
 4298 0244 2C        		.byte	44
 4299 0245 1A        		.byte	26
 4300 0246 1B        		.byte	27
 4301 0247 6E        		.byte	110
 4302 0248 5A        		.byte	90
 4303 0249 A0        		.byte	-96
 4304 024a 52        		.byte	82
 4305 024b 3B        		.byte	59
 4306 024c D6        		.byte	-42
 4307 024d B3        		.byte	-77
 4308 024e 29        		.byte	41
 4309 024f E3        		.byte	-29
 4310 0250 2F        		.byte	47
 4311 0251 84        		.byte	-124
 4312 0252 53        		.byte	83
 4313 0253 D1        		.byte	-47
 4314 0254 00        		.byte	0
 4315 0255 ED        		.byte	-19
 4316 0256 20        		.byte	32
 4317 0257 FC        		.byte	-4
 4318 0258 B1        		.byte	-79
 4319 0259 5B        		.byte	91
 4320 025a 6A        		.byte	106
 4321 025b CB        		.byte	-53
 4322 025c BE        		.byte	-66
 4323 025d 39        		.byte	57
 4324 025e 4A        		.byte	74
 4325 025f 4C        		.byte	76
 4326 0260 58        		.byte	88
 4327 0261 CF        		.byte	-49
 4328 0262 D0        		.byte	-48
 4329 0263 EF        		.byte	-17
 4330 0264 AA        		.byte	-86
 4331 0265 FB        		.byte	-5
 4332 0266 43        		.byte	67
 4333 0267 4D        		.byte	77
 4334 0268 33        		.byte	51
 4335 0269 85        		.byte	-123
 4336 026a 45        		.byte	69
 4337 026b F9        		.byte	-7
 4338 026c 02        		.byte	2
 4339 026d 7F        		.byte	127
 4340 026e 50        		.byte	80
 4341 026f 3C        		.byte	60
 4342 0270 9F        		.byte	-97
 4343 0271 A8        		.byte	-88
 4344 0272 51        		.byte	81
 4345 0273 A3        		.byte	-93
 4346 0274 40        		.byte	64
 4347 0275 8F        		.byte	-113
 4348 0276 92        		.byte	-110
 4349 0277 9D        		.byte	-99
 4350 0278 38        		.byte	56
 4351 0279 F5        		.byte	-11
 4352 027a BC        		.byte	-68
 4353 027b B6        		.byte	-74
 4354 027c DA        		.byte	-38
 4355 027d 21        		.byte	33
 4356 027e 10        		.byte	16
 4357 027f FF        		.byte	-1
 4358 0280 F3        		.byte	-13
 4359 0281 D2        		.byte	-46
 4360 0282 CD        		.byte	-51
 4361 0283 0C        		.byte	12
 4362 0284 13        		.byte	19
 4363 0285 EC        		.byte	-20
 4364 0286 5F        		.byte	95
 4365 0287 97        		.byte	-105
 4366 0288 44        		.byte	68
 4367 0289 17        		.byte	23
 4368 028a C4        		.byte	-60
 4369 028b A7        		.byte	-89
 4370 028c 7E        		.byte	126
 4371 028d 3D        		.byte	61
 4372 028e 64        		.byte	100
 4373 028f 5D        		.byte	93
 4374 0290 19        		.byte	25
 4375 0291 73        		.byte	115
 4376 0292 60        		.byte	96
 4377 0293 81        		.byte	-127
 4378 0294 4F        		.byte	79
 4379 0295 DC        		.byte	-36
 4380 0296 22        		.byte	34
 4381 0297 2A        		.byte	42
 4382 0298 90        		.byte	-112
 4383 0299 88        		.byte	-120
 4384 029a 46        		.byte	70
 4385 029b EE        		.byte	-18
 4386 029c B8        		.byte	-72
 4387 029d 14        		.byte	20
 4388 029e DE        		.byte	-34
 4389 029f 5E        		.byte	94
 4390 02a0 0B        		.byte	11
 4391 02a1 DB        		.byte	-37
 4392 02a2 E0        		.byte	-32
 4393 02a3 32        		.byte	50
 4394 02a4 3A        		.byte	58
 4395 02a5 0A        		.byte	10
 4396 02a6 49        		.byte	73
 4397 02a7 06        		.byte	6
 4398 02a8 24        		.byte	36
 4399 02a9 5C        		.byte	92
 4400 02aa C2        		.byte	-62
 4401 02ab D3        		.byte	-45
 4402 02ac AC        		.byte	-84
 4403 02ad 62        		.byte	98
 4404 02ae 91        		.byte	-111
 4405 02af 95        		.byte	-107
 4406 02b0 E4        		.byte	-28
 4407 02b1 79        		.byte	121
 4408 02b2 E7        		.byte	-25
 4409 02b3 C8        		.byte	-56
 4410 02b4 37        		.byte	55
 4411 02b5 6D        		.byte	109
 4412 02b6 8D        		.byte	-115
 4413 02b7 D5        		.byte	-43
 4414 02b8 4E        		.byte	78
 4415 02b9 A9        		.byte	-87
 4416 02ba 6C        		.byte	108
 4417 02bb 56        		.byte	86
 4418 02bc F4        		.byte	-12
 4419 02bd EA        		.byte	-22
 4420 02be 65        		.byte	101
 4421 02bf 7A        		.byte	122
 4422 02c0 AE        		.byte	-82
 4423 02c1 08        		.byte	8
 4424 02c2 BA        		.byte	-70
 4425 02c3 78        		.byte	120
 4426 02c4 25        		.byte	37
 4427 02c5 2E        		.byte	46
 4428 02c6 1C        		.byte	28
 4429 02c7 A6        		.byte	-90
 4430 02c8 B4        		.byte	-76
 4431 02c9 C6        		.byte	-58
 4432 02ca E8        		.byte	-24
 4433 02cb DD        		.byte	-35
 4434 02cc 74        		.byte	116
 4435 02cd 1F        		.byte	31
 4436 02ce 4B        		.byte	75
 4437 02cf BD        		.byte	-67
 4438 02d0 8B        		.byte	-117
 4439 02d1 8A        		.byte	-118
 4440 02d2 70        		.byte	112
 4441 02d3 3E        		.byte	62
 4442 02d4 B5        		.byte	-75
 4443 02d5 66        		.byte	102
 4444 02d6 48        		.byte	72
 4445 02d7 03        		.byte	3
 4446 02d8 F6        		.byte	-10
 4447 02d9 0E        		.byte	14
 4448 02da 61        		.byte	97
 4449 02db 35        		.byte	53
 4450 02dc 57        		.byte	87
 4451 02dd B9        		.byte	-71
 4452 02de 86        		.byte	-122
 4453 02df C1        		.byte	-63
 4454 02e0 1D        		.byte	29
 4455 02e1 9E        		.byte	-98
 4456 02e2 E1        		.byte	-31
 4457 02e3 F8        		.byte	-8
 4458 02e4 98        		.byte	-104
 4459 02e5 11        		.byte	17
 4460 02e6 69        		.byte	105
 4461 02e7 D9        		.byte	-39
 4462 02e8 8E        		.byte	-114
 4463 02e9 94        		.byte	-108
 4464 02ea 9B        		.byte	-101
 4465 02eb 1E        		.byte	30
 4466 02ec 87        		.byte	-121
 4467 02ed E9        		.byte	-23
 4468 02ee CE        		.byte	-50
 4469 02ef 55        		.byte	85
 4470 02f0 28        		.byte	40
 4471 02f1 DF        		.byte	-33
 4472 02f2 8C        		.byte	-116
 4473 02f3 A1        		.byte	-95
 4474 02f4 89        		.byte	-119
 4475 02f5 0D        		.byte	13
 4476 02f6 BF        		.byte	-65
 4477 02f7 E6        		.byte	-26
 4478 02f8 42        		.byte	66
 4479 02f9 68        		.byte	104
 4480 02fa 41        		.byte	65
 4481 02fb 99        		.byte	-103
 4482 02fc 2D        		.byte	45
 4483 02fd 0F        		.byte	15
 4484 02fe B0        		.byte	-80
 4485 02ff 54        		.byte	84
 4486 0300 BB        		.byte	-69
 4487 0301 16        		.byte	22
 4488               		.local	Iv
 4489               		.comm	Iv,2,1
 4490               		.local	Key
 4491               		.comm	Key,2,1
 4492               		.local	RoundKey
 4493               		.comm	RoundKey,176,1
 4494               		.local	state
 4495               		.comm	state,2,1
 4496               	.global	key
 4499               	key:
 4500 0302 2B        		.byte	43
 4501 0303 7E        		.byte	126
 4502 0304 15        		.byte	21
 4503 0305 16        		.byte	22
 4504 0306 28        		.byte	40
 4505 0307 AE        		.byte	-82
 4506 0308 D2        		.byte	-46
 4507 0309 A6        		.byte	-90
 4508 030a AB        		.byte	-85
 4509 030b F7        		.byte	-9
 4510 030c 15        		.byte	21
 4511 030d 88        		.byte	-120
 4512 030e 09        		.byte	9
 4513 030f CF        		.byte	-49
 4514 0310 4F        		.byte	79
 4515 0311 3C        		.byte	60
 4516               	.global	iv
 4519               	iv:
 4520 0312 00        		.byte	0
 4521 0313 01        		.byte	1
 4522 0314 02        		.byte	2
 4523 0315 03        		.byte	3
 4524 0316 04        		.byte	4
 4525 0317 05        		.byte	5
 4526 0318 06        		.byte	6
 4527 0319 07        		.byte	7
 4528 031a 08        		.byte	8
 4529 031b 09        		.byte	9
 4530 031c 0A        		.byte	10
 4531 031d 0B        		.byte	11
 4532 031e 0C        		.byte	12
 4533 031f 0D        		.byte	13
 4534 0320 0E        		.byte	14
 4535 0321 0F        		.byte	15
 4536               		.text
 4537               	.Letext0:
 4538               		.file 3 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/stdint.h"
 4539               		.file 4 "/usr/local/Cellar/avr-gcc/7.2.0/lib/gcc/avr/7.2.0/include/stddef.h"
 4540               		.file 5 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/stdlib.h"
 4541               		.file 6 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/avr/eeprom.h"
 4542               		.file 7 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4      *ABS*:000000000000003f __SREG__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:12     .text:0000000000000000 XorWithIv
                             .bss:0000000000000002 Iv
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:50     .text:0000000000000024 KeyExpansion
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4489   .bss:0000000000000004 Key
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4491   .bss:0000000000000006 RoundKey
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4231   .rodata:0000000000000202 sbox
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3714   .rodata:0000000000000003 Rcon
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:314    .text:0000000000000176 AddRoundKey
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4493   .bss:00000000000000b6 state
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:387    .text:00000000000001c6 SubBytes
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:441    .text:00000000000001f4 ShiftRows
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:502    .text:000000000000022e xtime
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:530    .text:0000000000000244 InvSubBytes
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3972   .rodata:0000000000000102 rsbox
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:584    .text:0000000000000272 InvShiftRows
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:645    .text:00000000000002ac Cipher
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:822    .text:0000000000000364 InvCipher
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1108   .text:00000000000004c8 sendchar
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1138   .text:00000000000004e0 PrintDecInt
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1238   .init9:0000000000000000 __jumpMain
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1249   *ABS*:00000000000021ff __stack
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1429   .text.startup:0000000000000000 main
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1288   .text:0000000000000548 delay_ms
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:1334   .text:0000000000000566 getData
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3709   .bss:0000000000000000 app_start
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3416   .data:0000000000000124 receivedPacket
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4499   .rodata:0000000000000302 key
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:4519   .rodata:0000000000000312 iv
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3124   .data:0000000000000004 aes_buffer
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3116   .data:0000000000000000 authenticationToken
                            *COM*:0000000000000004 authenticationNumber
/var/folders/41/pd6l_jps15x7b0187y6x9sz40000gn/T//ccuVkFdh.s:3107   .rodata:0000000000000000 CSWTCH.140

UNDEFINED SYMBOLS
__divmodhi4
memcpy
__bswapsi2
eeprom_write_byte
__do_copy_data
__do_clear_bss
